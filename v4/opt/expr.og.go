// Code generated by optgen; DO NOT EDIT.

package opt

import (
	"crypto/md5"
	"unsafe"
)

type childCountLookupFunc func(e *Expr) int

var childCountLookup = []childCountLookupFunc{
	// UnknownOp
	func(e *Expr) int {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(e *Expr) int {
		return 2
	},

	// VariableOp
	func(e *Expr) int {
		return 0
	},

	// ConstOp
	func(e *Expr) int {
		return 0
	},

	// PlaceholderOp
	func(e *Expr) int {
		return 0
	},

	// ListOp
	func(e *Expr) int {
		listExpr := (*listExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return 0 + int(listExpr.items.len)
	},

	// OrderedListOp
	func(e *Expr) int {
		orderedListExpr := (*orderedListExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return 0 + int(orderedListExpr.items.len)
	},

	// FilterListOp
	func(e *Expr) int {
		filterListExpr := (*filterListExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return 0 + int(filterListExpr.conditions.len)
	},

	// ProjectionsOp
	func(e *Expr) int {
		projectionsExpr := (*projectionsExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return 0 + int(projectionsExpr.items.len)
	},

	// ExistsOp
	func(e *Expr) int {
		return 1
	},

	// AndOp
	func(e *Expr) int {
		return 2
	},

	// OrOp
	func(e *Expr) int {
		return 2
	},

	// NotOp
	func(e *Expr) int {
		return 1
	},

	// EqOp
	func(e *Expr) int {
		return 2
	},

	// LtOp
	func(e *Expr) int {
		return 2
	},

	// GtOp
	func(e *Expr) int {
		return 2
	},

	// LeOp
	func(e *Expr) int {
		return 2
	},

	// GeOp
	func(e *Expr) int {
		return 2
	},

	// NeOp
	func(e *Expr) int {
		return 2
	},

	// InOp
	func(e *Expr) int {
		return 2
	},

	// NotInOp
	func(e *Expr) int {
		return 2
	},

	// LikeOp
	func(e *Expr) int {
		return 2
	},

	// NotLikeOp
	func(e *Expr) int {
		return 2
	},

	// ILikeOp
	func(e *Expr) int {
		return 2
	},

	// NotILikeOp
	func(e *Expr) int {
		return 2
	},

	// SimilarToOp
	func(e *Expr) int {
		return 2
	},

	// NotSimilarToOp
	func(e *Expr) int {
		return 2
	},

	// RegMatchOp
	func(e *Expr) int {
		return 2
	},

	// NotRegMatchOp
	func(e *Expr) int {
		return 2
	},

	// RegIMatchOp
	func(e *Expr) int {
		return 2
	},

	// NotRegIMatchOp
	func(e *Expr) int {
		return 2
	},

	// IsDistinctFromOp
	func(e *Expr) int {
		return 2
	},

	// IsNotDistinctFromOp
	func(e *Expr) int {
		return 2
	},

	// IsOp
	func(e *Expr) int {
		return 2
	},

	// IsNotOp
	func(e *Expr) int {
		return 2
	},

	// AnyOp
	func(e *Expr) int {
		return 2
	},

	// SomeOp
	func(e *Expr) int {
		return 2
	},

	// AllOp
	func(e *Expr) int {
		return 2
	},

	// BitandOp
	func(e *Expr) int {
		return 2
	},

	// BitorOp
	func(e *Expr) int {
		return 2
	},

	// BitxorOp
	func(e *Expr) int {
		return 2
	},

	// PlusOp
	func(e *Expr) int {
		return 2
	},

	// MinusOp
	func(e *Expr) int {
		return 2
	},

	// MultOp
	func(e *Expr) int {
		return 2
	},

	// DivOp
	func(e *Expr) int {
		return 2
	},

	// FloorDivOp
	func(e *Expr) int {
		return 2
	},

	// ModOp
	func(e *Expr) int {
		return 2
	},

	// PowOp
	func(e *Expr) int {
		return 2
	},

	// ConcatOp
	func(e *Expr) int {
		return 2
	},

	// LShiftOp
	func(e *Expr) int {
		return 2
	},

	// RShiftOp
	func(e *Expr) int {
		return 2
	},

	// UnaryPlusOp
	func(e *Expr) int {
		return 1
	},

	// UnaryMinusOp
	func(e *Expr) int {
		return 1
	},

	// UnaryComplementOp
	func(e *Expr) int {
		return 1
	},

	// FunctionOp
	func(e *Expr) int {
		functionExpr := (*functionExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return 0 + int(functionExpr.args.len)
	},

	// TrueOp
	func(e *Expr) int {
		return 0
	},

	// FalseOp
	func(e *Expr) int {
		return 0
	},

	// ScanOp
	func(e *Expr) int {
		return 0
	},

	// ValuesOp
	func(e *Expr) int {
		return 0
	},

	// SelectOp
	func(e *Expr) int {
		return 2
	},

	// ProjectOp
	func(e *Expr) int {
		return 2
	},

	// InnerJoinOp
	func(e *Expr) int {
		return 3
	},

	// LeftJoinOp
	func(e *Expr) int {
		return 3
	},

	// RightJoinOp
	func(e *Expr) int {
		return 3
	},

	// FullJoinOp
	func(e *Expr) int {
		return 3
	},

	// SemiJoinOp
	func(e *Expr) int {
		return 3
	},

	// AntiJoinOp
	func(e *Expr) int {
		return 3
	},

	// InnerJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// LeftJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// RightJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// FullJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// SemiJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// AntiJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// GroupByOp
	func(e *Expr) int {
		return 3
	},

	// UnionOp
	func(e *Expr) int {
		return 2
	},

	// IntersectOp
	func(e *Expr) int {
		return 2
	},

	// ExceptOp
	func(e *Expr) int {
		return 2
	},

	// SortOp
	func(e *Expr) int {
		return 1
	},

	// ArrangeOp
	func(e *Expr) int {
		return 1
	},
}

type childGroupLookupFunc func(e *Expr, n int) GroupID

var childGroupLookup = []childGroupLookupFunc{
	// UnknownOp
	func(e *Expr, n int) GroupID {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(e *Expr, n int) GroupID {
		subqueryExpr := (*subqueryExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return subqueryExpr.input
		case 1:
			return subqueryExpr.projection
		default:
			panic("child index out of range")
		}
	},

	// VariableOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// ConstOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// PlaceholderOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// ListOp
	func(e *Expr, n int) GroupID {
		listExpr := (*listExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		default:
			list := e.mem.lookupList(listExpr.items)
			return list[n-0]
		}
	},

	// OrderedListOp
	func(e *Expr, n int) GroupID {
		orderedListExpr := (*orderedListExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		default:
			list := e.mem.lookupList(orderedListExpr.items)
			return list[n-0]
		}
	},

	// FilterListOp
	func(e *Expr, n int) GroupID {
		filterListExpr := (*filterListExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		default:
			list := e.mem.lookupList(filterListExpr.conditions)
			return list[n-0]
		}
	},

	// ProjectionsOp
	func(e *Expr, n int) GroupID {
		projectionsExpr := (*projectionsExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		default:
			list := e.mem.lookupList(projectionsExpr.items)
			return list[n-0]
		}
	},

	// ExistsOp
	func(e *Expr, n int) GroupID {
		existsExpr := (*existsExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return existsExpr.input
		default:
			panic("child index out of range")
		}
	},

	// AndOp
	func(e *Expr, n int) GroupID {
		andExpr := (*andExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return andExpr.left
		case 1:
			return andExpr.right
		default:
			panic("child index out of range")
		}
	},

	// OrOp
	func(e *Expr, n int) GroupID {
		orExpr := (*orExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return orExpr.left
		case 1:
			return orExpr.right
		default:
			panic("child index out of range")
		}
	},

	// NotOp
	func(e *Expr, n int) GroupID {
		notExpr := (*notExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return notExpr.input
		default:
			panic("child index out of range")
		}
	},

	// EqOp
	func(e *Expr, n int) GroupID {
		eqExpr := (*eqExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return eqExpr.left
		case 1:
			return eqExpr.right
		default:
			panic("child index out of range")
		}
	},

	// LtOp
	func(e *Expr, n int) GroupID {
		ltExpr := (*ltExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return ltExpr.left
		case 1:
			return ltExpr.right
		default:
			panic("child index out of range")
		}
	},

	// GtOp
	func(e *Expr, n int) GroupID {
		gtExpr := (*gtExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return gtExpr.left
		case 1:
			return gtExpr.right
		default:
			panic("child index out of range")
		}
	},

	// LeOp
	func(e *Expr, n int) GroupID {
		leExpr := (*leExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return leExpr.left
		case 1:
			return leExpr.right
		default:
			panic("child index out of range")
		}
	},

	// GeOp
	func(e *Expr, n int) GroupID {
		geExpr := (*geExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return geExpr.left
		case 1:
			return geExpr.right
		default:
			panic("child index out of range")
		}
	},

	// NeOp
	func(e *Expr, n int) GroupID {
		neExpr := (*neExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return neExpr.left
		case 1:
			return neExpr.right
		default:
			panic("child index out of range")
		}
	},

	// InOp
	func(e *Expr, n int) GroupID {
		inExpr := (*inExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return inExpr.left
		case 1:
			return inExpr.right
		default:
			panic("child index out of range")
		}
	},

	// NotInOp
	func(e *Expr, n int) GroupID {
		notInExpr := (*notInExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return notInExpr.left
		case 1:
			return notInExpr.right
		default:
			panic("child index out of range")
		}
	},

	// LikeOp
	func(e *Expr, n int) GroupID {
		likeExpr := (*likeExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return likeExpr.left
		case 1:
			return likeExpr.right
		default:
			panic("child index out of range")
		}
	},

	// NotLikeOp
	func(e *Expr, n int) GroupID {
		notLikeExpr := (*notLikeExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return notLikeExpr.left
		case 1:
			return notLikeExpr.right
		default:
			panic("child index out of range")
		}
	},

	// ILikeOp
	func(e *Expr, n int) GroupID {
		iLikeExpr := (*iLikeExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return iLikeExpr.left
		case 1:
			return iLikeExpr.right
		default:
			panic("child index out of range")
		}
	},

	// NotILikeOp
	func(e *Expr, n int) GroupID {
		notILikeExpr := (*notILikeExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return notILikeExpr.left
		case 1:
			return notILikeExpr.right
		default:
			panic("child index out of range")
		}
	},

	// SimilarToOp
	func(e *Expr, n int) GroupID {
		similarToExpr := (*similarToExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return similarToExpr.left
		case 1:
			return similarToExpr.right
		default:
			panic("child index out of range")
		}
	},

	// NotSimilarToOp
	func(e *Expr, n int) GroupID {
		notSimilarToExpr := (*notSimilarToExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return notSimilarToExpr.left
		case 1:
			return notSimilarToExpr.right
		default:
			panic("child index out of range")
		}
	},

	// RegMatchOp
	func(e *Expr, n int) GroupID {
		regMatchExpr := (*regMatchExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return regMatchExpr.left
		case 1:
			return regMatchExpr.right
		default:
			panic("child index out of range")
		}
	},

	// NotRegMatchOp
	func(e *Expr, n int) GroupID {
		notRegMatchExpr := (*notRegMatchExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return notRegMatchExpr.left
		case 1:
			return notRegMatchExpr.right
		default:
			panic("child index out of range")
		}
	},

	// RegIMatchOp
	func(e *Expr, n int) GroupID {
		regIMatchExpr := (*regIMatchExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return regIMatchExpr.left
		case 1:
			return regIMatchExpr.right
		default:
			panic("child index out of range")
		}
	},

	// NotRegIMatchOp
	func(e *Expr, n int) GroupID {
		notRegIMatchExpr := (*notRegIMatchExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return notRegIMatchExpr.left
		case 1:
			return notRegIMatchExpr.right
		default:
			panic("child index out of range")
		}
	},

	// IsDistinctFromOp
	func(e *Expr, n int) GroupID {
		isDistinctFromExpr := (*isDistinctFromExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return isDistinctFromExpr.left
		case 1:
			return isDistinctFromExpr.right
		default:
			panic("child index out of range")
		}
	},

	// IsNotDistinctFromOp
	func(e *Expr, n int) GroupID {
		isNotDistinctFromExpr := (*isNotDistinctFromExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return isNotDistinctFromExpr.left
		case 1:
			return isNotDistinctFromExpr.right
		default:
			panic("child index out of range")
		}
	},

	// IsOp
	func(e *Expr, n int) GroupID {
		isExpr := (*isExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return isExpr.left
		case 1:
			return isExpr.right
		default:
			panic("child index out of range")
		}
	},

	// IsNotOp
	func(e *Expr, n int) GroupID {
		isNotExpr := (*isNotExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return isNotExpr.left
		case 1:
			return isNotExpr.right
		default:
			panic("child index out of range")
		}
	},

	// AnyOp
	func(e *Expr, n int) GroupID {
		anyExpr := (*anyExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return anyExpr.left
		case 1:
			return anyExpr.right
		default:
			panic("child index out of range")
		}
	},

	// SomeOp
	func(e *Expr, n int) GroupID {
		someExpr := (*someExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return someExpr.left
		case 1:
			return someExpr.right
		default:
			panic("child index out of range")
		}
	},

	// AllOp
	func(e *Expr, n int) GroupID {
		allExpr := (*allExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return allExpr.left
		case 1:
			return allExpr.right
		default:
			panic("child index out of range")
		}
	},

	// BitandOp
	func(e *Expr, n int) GroupID {
		bitandExpr := (*bitandExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return bitandExpr.left
		case 1:
			return bitandExpr.right
		default:
			panic("child index out of range")
		}
	},

	// BitorOp
	func(e *Expr, n int) GroupID {
		bitorExpr := (*bitorExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return bitorExpr.left
		case 1:
			return bitorExpr.right
		default:
			panic("child index out of range")
		}
	},

	// BitxorOp
	func(e *Expr, n int) GroupID {
		bitxorExpr := (*bitxorExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return bitxorExpr.left
		case 1:
			return bitxorExpr.right
		default:
			panic("child index out of range")
		}
	},

	// PlusOp
	func(e *Expr, n int) GroupID {
		plusExpr := (*plusExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return plusExpr.left
		case 1:
			return plusExpr.right
		default:
			panic("child index out of range")
		}
	},

	// MinusOp
	func(e *Expr, n int) GroupID {
		minusExpr := (*minusExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return minusExpr.left
		case 1:
			return minusExpr.right
		default:
			panic("child index out of range")
		}
	},

	// MultOp
	func(e *Expr, n int) GroupID {
		multExpr := (*multExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return multExpr.left
		case 1:
			return multExpr.right
		default:
			panic("child index out of range")
		}
	},

	// DivOp
	func(e *Expr, n int) GroupID {
		divExpr := (*divExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return divExpr.left
		case 1:
			return divExpr.right
		default:
			panic("child index out of range")
		}
	},

	// FloorDivOp
	func(e *Expr, n int) GroupID {
		floorDivExpr := (*floorDivExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return floorDivExpr.left
		case 1:
			return floorDivExpr.right
		default:
			panic("child index out of range")
		}
	},

	// ModOp
	func(e *Expr, n int) GroupID {
		modExpr := (*modExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return modExpr.left
		case 1:
			return modExpr.right
		default:
			panic("child index out of range")
		}
	},

	// PowOp
	func(e *Expr, n int) GroupID {
		powExpr := (*powExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return powExpr.left
		case 1:
			return powExpr.right
		default:
			panic("child index out of range")
		}
	},

	// ConcatOp
	func(e *Expr, n int) GroupID {
		concatExpr := (*concatExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return concatExpr.left
		case 1:
			return concatExpr.right
		default:
			panic("child index out of range")
		}
	},

	// LShiftOp
	func(e *Expr, n int) GroupID {
		lShiftExpr := (*lShiftExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return lShiftExpr.left
		case 1:
			return lShiftExpr.right
		default:
			panic("child index out of range")
		}
	},

	// RShiftOp
	func(e *Expr, n int) GroupID {
		rShiftExpr := (*rShiftExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return rShiftExpr.left
		case 1:
			return rShiftExpr.right
		default:
			panic("child index out of range")
		}
	},

	// UnaryPlusOp
	func(e *Expr, n int) GroupID {
		unaryPlusExpr := (*unaryPlusExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return unaryPlusExpr.input
		default:
			panic("child index out of range")
		}
	},

	// UnaryMinusOp
	func(e *Expr, n int) GroupID {
		unaryMinusExpr := (*unaryMinusExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return unaryMinusExpr.input
		default:
			panic("child index out of range")
		}
	},

	// UnaryComplementOp
	func(e *Expr, n int) GroupID {
		unaryComplementExpr := (*unaryComplementExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return unaryComplementExpr.input
		default:
			panic("child index out of range")
		}
	},

	// FunctionOp
	func(e *Expr, n int) GroupID {
		functionExpr := (*functionExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		default:
			list := e.mem.lookupList(functionExpr.args)
			return list[n-0]
		}
	},

	// TrueOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// FalseOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// ScanOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// ValuesOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// SelectOp
	func(e *Expr, n int) GroupID {
		selectExpr := (*selectExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return selectExpr.input
		case 1:
			return selectExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// ProjectOp
	func(e *Expr, n int) GroupID {
		projectExpr := (*projectExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return projectExpr.input
		case 1:
			return projectExpr.projections
		default:
			panic("child index out of range")
		}
	},

	// InnerJoinOp
	func(e *Expr, n int) GroupID {
		innerJoinExpr := (*innerJoinExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return innerJoinExpr.left
		case 1:
			return innerJoinExpr.right
		case 2:
			return innerJoinExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// LeftJoinOp
	func(e *Expr, n int) GroupID {
		leftJoinExpr := (*leftJoinExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return leftJoinExpr.left
		case 1:
			return leftJoinExpr.right
		case 2:
			return leftJoinExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// RightJoinOp
	func(e *Expr, n int) GroupID {
		rightJoinExpr := (*rightJoinExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return rightJoinExpr.left
		case 1:
			return rightJoinExpr.right
		case 2:
			return rightJoinExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// FullJoinOp
	func(e *Expr, n int) GroupID {
		fullJoinExpr := (*fullJoinExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return fullJoinExpr.left
		case 1:
			return fullJoinExpr.right
		case 2:
			return fullJoinExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// SemiJoinOp
	func(e *Expr, n int) GroupID {
		semiJoinExpr := (*semiJoinExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return semiJoinExpr.left
		case 1:
			return semiJoinExpr.right
		case 2:
			return semiJoinExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// AntiJoinOp
	func(e *Expr, n int) GroupID {
		antiJoinExpr := (*antiJoinExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return antiJoinExpr.left
		case 1:
			return antiJoinExpr.right
		case 2:
			return antiJoinExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// InnerJoinApplyOp
	func(e *Expr, n int) GroupID {
		innerJoinApplyExpr := (*innerJoinApplyExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return innerJoinApplyExpr.left
		case 1:
			return innerJoinApplyExpr.right
		case 2:
			return innerJoinApplyExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// LeftJoinApplyOp
	func(e *Expr, n int) GroupID {
		leftJoinApplyExpr := (*leftJoinApplyExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return leftJoinApplyExpr.left
		case 1:
			return leftJoinApplyExpr.right
		case 2:
			return leftJoinApplyExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// RightJoinApplyOp
	func(e *Expr, n int) GroupID {
		rightJoinApplyExpr := (*rightJoinApplyExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return rightJoinApplyExpr.left
		case 1:
			return rightJoinApplyExpr.right
		case 2:
			return rightJoinApplyExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// FullJoinApplyOp
	func(e *Expr, n int) GroupID {
		fullJoinApplyExpr := (*fullJoinApplyExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return fullJoinApplyExpr.left
		case 1:
			return fullJoinApplyExpr.right
		case 2:
			return fullJoinApplyExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// SemiJoinApplyOp
	func(e *Expr, n int) GroupID {
		semiJoinApplyExpr := (*semiJoinApplyExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return semiJoinApplyExpr.left
		case 1:
			return semiJoinApplyExpr.right
		case 2:
			return semiJoinApplyExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// AntiJoinApplyOp
	func(e *Expr, n int) GroupID {
		antiJoinApplyExpr := (*antiJoinApplyExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return antiJoinApplyExpr.left
		case 1:
			return antiJoinApplyExpr.right
		case 2:
			return antiJoinApplyExpr.filter
		default:
			panic("child index out of range")
		}
	},

	// GroupByOp
	func(e *Expr, n int) GroupID {
		groupByExpr := (*groupByExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return groupByExpr.input
		case 1:
			return groupByExpr.groupings
		case 2:
			return groupByExpr.aggregations
		default:
			panic("child index out of range")
		}
	},

	// UnionOp
	func(e *Expr, n int) GroupID {
		unionExpr := (*unionExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return unionExpr.left
		case 1:
			return unionExpr.right
		default:
			panic("child index out of range")
		}
	},

	// IntersectOp
	func(e *Expr, n int) GroupID {
		intersectExpr := (*intersectExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return intersectExpr.left
		case 1:
			return intersectExpr.right
		default:
			panic("child index out of range")
		}
	},

	// ExceptOp
	func(e *Expr, n int) GroupID {
		exceptExpr := (*exceptExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))

		switch n {
		case 0:
			return exceptExpr.left
		case 1:
			return exceptExpr.right
		default:
			panic("child index out of range")
		}
	},

	// SortOp
	func(e *Expr, n int) GroupID {
		if n == 0 {
			return e.group
		}

		panic("child index out of range")
	},

	// ArrangeOp
	func(e *Expr, n int) GroupID {
		if n == 0 {
			return e.group
		}

		panic("child index out of range")
	},
}

type privateLookupFunc func(e *Expr) PrivateID

var privateLookup = []privateLookupFunc{
	// UnknownOp
	func(e *Expr) PrivateID {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(e *Expr) PrivateID {
		return 0
	},

	// VariableOp
	func(e *Expr) PrivateID {
		variableExpr := (*variableExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return variableExpr.col
	},

	// ConstOp
	func(e *Expr) PrivateID {
		constExpr := (*constExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return constExpr.value
	},

	// PlaceholderOp
	func(e *Expr) PrivateID {
		placeholderExpr := (*placeholderExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return placeholderExpr.value
	},

	// ListOp
	func(e *Expr) PrivateID {
		return 0
	},

	// OrderedListOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FilterListOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ProjectionsOp
	func(e *Expr) PrivateID {
		projectionsExpr := (*projectionsExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return projectionsExpr.cols
	},

	// ExistsOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AndOp
	func(e *Expr) PrivateID {
		return 0
	},

	// OrOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotOp
	func(e *Expr) PrivateID {
		return 0
	},

	// EqOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LtOp
	func(e *Expr) PrivateID {
		return 0
	},

	// GtOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// GeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// InOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotInOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LikeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotLikeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ILikeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotILikeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SimilarToOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotSimilarToOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RegMatchOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotRegMatchOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RegIMatchOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotRegIMatchOp
	func(e *Expr) PrivateID {
		return 0
	},

	// IsDistinctFromOp
	func(e *Expr) PrivateID {
		return 0
	},

	// IsNotDistinctFromOp
	func(e *Expr) PrivateID {
		return 0
	},

	// IsOp
	func(e *Expr) PrivateID {
		return 0
	},

	// IsNotOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AnyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SomeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AllOp
	func(e *Expr) PrivateID {
		return 0
	},

	// BitandOp
	func(e *Expr) PrivateID {
		return 0
	},

	// BitorOp
	func(e *Expr) PrivateID {
		return 0
	},

	// BitxorOp
	func(e *Expr) PrivateID {
		return 0
	},

	// PlusOp
	func(e *Expr) PrivateID {
		return 0
	},

	// MinusOp
	func(e *Expr) PrivateID {
		return 0
	},

	// MultOp
	func(e *Expr) PrivateID {
		return 0
	},

	// DivOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FloorDivOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ModOp
	func(e *Expr) PrivateID {
		return 0
	},

	// PowOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ConcatOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LShiftOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RShiftOp
	func(e *Expr) PrivateID {
		return 0
	},

	// UnaryPlusOp
	func(e *Expr) PrivateID {
		return 0
	},

	// UnaryMinusOp
	func(e *Expr) PrivateID {
		return 0
	},

	// UnaryComplementOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FunctionOp
	func(e *Expr) PrivateID {
		functionExpr := (*functionExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return functionExpr.def
	},

	// TrueOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FalseOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ScanOp
	func(e *Expr) PrivateID {
		scanExpr := (*scanExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return scanExpr.table
	},

	// ValuesOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SelectOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ProjectOp
	func(e *Expr) PrivateID {
		return 0
	},

	// InnerJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LeftJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RightJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FullJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SemiJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AntiJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// InnerJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LeftJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RightJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FullJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SemiJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AntiJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// GroupByOp
	func(e *Expr) PrivateID {
		return 0
	},

	// UnionOp
	func(e *Expr) PrivateID {
		unionExpr := (*unionExpr)(unsafe.Pointer(e.mem.lookupExpr(e.offset)))
		return unionExpr.colMap
	},

	// IntersectOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ExceptOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SortOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ArrangeOp
	func(e *Expr) PrivateID {
		return 0
	},
}

var isScalarLookup = []bool{
	false, // UnknownOp

	true,  // SubqueryOp
	true,  // VariableOp
	true,  // ConstOp
	true,  // PlaceholderOp
	true,  // ListOp
	true,  // OrderedListOp
	true,  // FilterListOp
	true,  // ProjectionsOp
	true,  // ExistsOp
	true,  // AndOp
	true,  // OrOp
	true,  // NotOp
	true,  // EqOp
	true,  // LtOp
	true,  // GtOp
	true,  // LeOp
	true,  // GeOp
	true,  // NeOp
	true,  // InOp
	true,  // NotInOp
	true,  // LikeOp
	true,  // NotLikeOp
	true,  // ILikeOp
	true,  // NotILikeOp
	true,  // SimilarToOp
	true,  // NotSimilarToOp
	true,  // RegMatchOp
	true,  // NotRegMatchOp
	true,  // RegIMatchOp
	true,  // NotRegIMatchOp
	true,  // IsDistinctFromOp
	true,  // IsNotDistinctFromOp
	true,  // IsOp
	true,  // IsNotOp
	true,  // AnyOp
	true,  // SomeOp
	true,  // AllOp
	true,  // BitandOp
	true,  // BitorOp
	true,  // BitxorOp
	true,  // PlusOp
	true,  // MinusOp
	true,  // MultOp
	true,  // DivOp
	true,  // FloorDivOp
	true,  // ModOp
	true,  // PowOp
	true,  // ConcatOp
	true,  // LShiftOp
	true,  // RShiftOp
	true,  // UnaryPlusOp
	true,  // UnaryMinusOp
	true,  // UnaryComplementOp
	true,  // FunctionOp
	true,  // TrueOp
	true,  // FalseOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // ArrangeOp
}

var isRelationalLookup = []bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // PlaceholderOp
	false, // ListOp
	false, // OrderedListOp
	false, // FilterListOp
	false, // ProjectionsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsDistinctFromOp
	false, // IsNotDistinctFromOp
	false, // IsOp
	false, // IsNotOp
	false, // AnyOp
	false, // SomeOp
	false, // AllOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // TrueOp
	false, // FalseOp
	true,  // ScanOp
	true,  // ValuesOp
	true,  // SelectOp
	true,  // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	true,  // GroupByOp
	true,  // UnionOp
	true,  // IntersectOp
	true,  // ExceptOp
	true,  // SortOp
	true,  // ArrangeOp
}

var isJoinLookup = []bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // PlaceholderOp
	false, // ListOp
	false, // OrderedListOp
	false, // FilterListOp
	false, // ProjectionsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsDistinctFromOp
	false, // IsNotDistinctFromOp
	false, // IsOp
	false, // IsNotOp
	false, // AnyOp
	false, // SomeOp
	false, // AllOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // TrueOp
	false, // FalseOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // ArrangeOp
}

var isJoinApplyLookup = []bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // PlaceholderOp
	false, // ListOp
	false, // OrderedListOp
	false, // FilterListOp
	false, // ProjectionsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsDistinctFromOp
	false, // IsNotDistinctFromOp
	false, // IsOp
	false, // IsNotOp
	false, // AnyOp
	false, // SomeOp
	false, // AllOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // TrueOp
	false, // FalseOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // ArrangeOp
}

var isEnforcerLookup = []bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // PlaceholderOp
	false, // ListOp
	false, // OrderedListOp
	false, // FilterListOp
	false, // ProjectionsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsDistinctFromOp
	false, // IsNotDistinctFromOp
	false, // IsOp
	false, // IsNotOp
	false, // AnyOp
	false, // SomeOp
	false, // AllOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // TrueOp
	false, // FalseOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	true,  // SortOp
	true,  // ArrangeOp
}

func (e *Expr) IsScalar() bool {
	return isScalarLookup[e.op]
}

func (e *Expr) IsRelational() bool {
	return isRelationalLookup[e.op]
}

func (e *Expr) IsJoin() bool {
	return isJoinLookup[e.op]
}

func (e *Expr) IsJoinApply() bool {
	return isJoinApplyLookup[e.op]
}

func (e *Expr) IsEnforcer() bool {
	return isEnforcerLookup[e.op]
}

type subqueryExpr struct {
	memoExpr
	input      GroupID
	projection GroupID
}

func (e *subqueryExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(subqueryExpr{})
	const offset = unsafe.Offsetof(subqueryExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asSubquery() *subqueryExpr {
	if m.op != SubqueryOp {
		return nil
	}

	return (*subqueryExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeSubquery(expr *subqueryExpr) GroupID {
	const size = uint32(unsafe.Sizeof(subqueryExpr{}))
	const align = uint32(unsafe.Alignof(subqueryExpr{}))

	if expr.input == 0 {
		panic("input child cannot be undefined")
	}

	if expr.projection == 0 {
		panic("projection child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*subqueryExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(SubqueryOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: SubqueryOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type variableExpr struct {
	memoExpr
	col PrivateID
}

func (e *variableExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(variableExpr{})
	const offset = unsafe.Offsetof(variableExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asVariable() *variableExpr {
	if m.op != VariableOp {
		return nil
	}

	return (*variableExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeVariable(expr *variableExpr) GroupID {
	const size = uint32(unsafe.Sizeof(variableExpr{}))
	const align = uint32(unsafe.Alignof(variableExpr{}))

	if expr.col == 0 {
		panic("col child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*variableExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(VariableOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: VariableOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type constExpr struct {
	memoExpr
	value PrivateID
}

func (e *constExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(constExpr{})
	const offset = unsafe.Offsetof(constExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asConst() *constExpr {
	if m.op != ConstOp {
		return nil
	}

	return (*constExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeConst(expr *constExpr) GroupID {
	const size = uint32(unsafe.Sizeof(constExpr{}))
	const align = uint32(unsafe.Alignof(constExpr{}))

	if expr.value == 0 {
		panic("value child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*constExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ConstOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ConstOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type placeholderExpr struct {
	memoExpr
	value PrivateID
}

func (e *placeholderExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(placeholderExpr{})
	const offset = unsafe.Offsetof(placeholderExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asPlaceholder() *placeholderExpr {
	if m.op != PlaceholderOp {
		return nil
	}

	return (*placeholderExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizePlaceholder(expr *placeholderExpr) GroupID {
	const size = uint32(unsafe.Sizeof(placeholderExpr{}))
	const align = uint32(unsafe.Alignof(placeholderExpr{}))

	if expr.value == 0 {
		panic("value child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*placeholderExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(PlaceholderOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: PlaceholderOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type listExpr struct {
	memoExpr
	items ListID
}

func (e *listExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(listExpr{})
	const offset = unsafe.Offsetof(listExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asList() *listExpr {
	if m.op != ListOp {
		return nil
	}

	return (*listExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeList(expr *listExpr) GroupID {
	const size = uint32(unsafe.Sizeof(listExpr{}))
	const align = uint32(unsafe.Alignof(listExpr{}))

	if expr.items == UndefinedList {
		panic("items child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*listExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ListOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ListOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type orderedListExpr struct {
	memoExpr
	items ListID
}

func (e *orderedListExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(orderedListExpr{})
	const offset = unsafe.Offsetof(orderedListExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asOrderedList() *orderedListExpr {
	if m.op != OrderedListOp {
		return nil
	}

	return (*orderedListExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeOrderedList(expr *orderedListExpr) GroupID {
	const size = uint32(unsafe.Sizeof(orderedListExpr{}))
	const align = uint32(unsafe.Alignof(orderedListExpr{}))

	if expr.items == UndefinedList {
		panic("items child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*orderedListExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(OrderedListOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: OrderedListOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type filterListExpr struct {
	memoExpr
	conditions ListID
}

func (e *filterListExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(filterListExpr{})
	const offset = unsafe.Offsetof(filterListExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asFilterList() *filterListExpr {
	if m.op != FilterListOp {
		return nil
	}

	return (*filterListExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeFilterList(expr *filterListExpr) GroupID {
	const size = uint32(unsafe.Sizeof(filterListExpr{}))
	const align = uint32(unsafe.Alignof(filterListExpr{}))

	if expr.conditions == UndefinedList {
		panic("conditions child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*filterListExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(FilterListOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: FilterListOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type projectionsExpr struct {
	memoExpr
	items ListID
	cols  PrivateID
}

func (e *projectionsExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(projectionsExpr{})
	const offset = unsafe.Offsetof(projectionsExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asProjections() *projectionsExpr {
	if m.op != ProjectionsOp {
		return nil
	}

	return (*projectionsExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeProjections(expr *projectionsExpr) GroupID {
	const size = uint32(unsafe.Sizeof(projectionsExpr{}))
	const align = uint32(unsafe.Alignof(projectionsExpr{}))

	if expr.items == UndefinedList {
		panic("items child cannot be undefined")
	}

	if expr.cols == 0 {
		panic("cols child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*projectionsExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ProjectionsOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ProjectionsOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type existsExpr struct {
	memoExpr
	input GroupID
}

func (e *existsExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(existsExpr{})
	const offset = unsafe.Offsetof(existsExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asExists() *existsExpr {
	if m.op != ExistsOp {
		return nil
	}

	return (*existsExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeExists(expr *existsExpr) GroupID {
	const size = uint32(unsafe.Sizeof(existsExpr{}))
	const align = uint32(unsafe.Alignof(existsExpr{}))

	if expr.input == 0 {
		panic("input child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*existsExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ExistsOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ExistsOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type andExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *andExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(andExpr{})
	const offset = unsafe.Offsetof(andExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asAnd() *andExpr {
	if m.op != AndOp {
		return nil
	}

	return (*andExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeAnd(expr *andExpr) GroupID {
	const size = uint32(unsafe.Sizeof(andExpr{}))
	const align = uint32(unsafe.Alignof(andExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*andExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(AndOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: AndOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type orExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *orExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(orExpr{})
	const offset = unsafe.Offsetof(orExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asOr() *orExpr {
	if m.op != OrOp {
		return nil
	}

	return (*orExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeOr(expr *orExpr) GroupID {
	const size = uint32(unsafe.Sizeof(orExpr{}))
	const align = uint32(unsafe.Alignof(orExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*orExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(OrOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: OrOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type notExpr struct {
	memoExpr
	input GroupID
}

func (e *notExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(notExpr{})
	const offset = unsafe.Offsetof(notExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asNot() *notExpr {
	if m.op != NotOp {
		return nil
	}

	return (*notExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeNot(expr *notExpr) GroupID {
	const size = uint32(unsafe.Sizeof(notExpr{}))
	const align = uint32(unsafe.Alignof(notExpr{}))

	if expr.input == 0 {
		panic("input child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*notExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(NotOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: NotOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type eqExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *eqExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(eqExpr{})
	const offset = unsafe.Offsetof(eqExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asEq() *eqExpr {
	if m.op != EqOp {
		return nil
	}

	return (*eqExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeEq(expr *eqExpr) GroupID {
	const size = uint32(unsafe.Sizeof(eqExpr{}))
	const align = uint32(unsafe.Alignof(eqExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*eqExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(EqOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: EqOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type ltExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *ltExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(ltExpr{})
	const offset = unsafe.Offsetof(ltExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asLt() *ltExpr {
	if m.op != LtOp {
		return nil
	}

	return (*ltExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeLt(expr *ltExpr) GroupID {
	const size = uint32(unsafe.Sizeof(ltExpr{}))
	const align = uint32(unsafe.Alignof(ltExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*ltExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(LtOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: LtOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type gtExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *gtExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(gtExpr{})
	const offset = unsafe.Offsetof(gtExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asGt() *gtExpr {
	if m.op != GtOp {
		return nil
	}

	return (*gtExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeGt(expr *gtExpr) GroupID {
	const size = uint32(unsafe.Sizeof(gtExpr{}))
	const align = uint32(unsafe.Alignof(gtExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*gtExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(GtOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: GtOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type leExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *leExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(leExpr{})
	const offset = unsafe.Offsetof(leExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asLe() *leExpr {
	if m.op != LeOp {
		return nil
	}

	return (*leExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeLe(expr *leExpr) GroupID {
	const size = uint32(unsafe.Sizeof(leExpr{}))
	const align = uint32(unsafe.Alignof(leExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*leExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(LeOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: LeOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type geExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *geExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(geExpr{})
	const offset = unsafe.Offsetof(geExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asGe() *geExpr {
	if m.op != GeOp {
		return nil
	}

	return (*geExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeGe(expr *geExpr) GroupID {
	const size = uint32(unsafe.Sizeof(geExpr{}))
	const align = uint32(unsafe.Alignof(geExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*geExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(GeOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: GeOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type neExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *neExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(neExpr{})
	const offset = unsafe.Offsetof(neExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asNe() *neExpr {
	if m.op != NeOp {
		return nil
	}

	return (*neExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeNe(expr *neExpr) GroupID {
	const size = uint32(unsafe.Sizeof(neExpr{}))
	const align = uint32(unsafe.Alignof(neExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*neExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(NeOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: NeOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type inExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *inExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(inExpr{})
	const offset = unsafe.Offsetof(inExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asIn() *inExpr {
	if m.op != InOp {
		return nil
	}

	return (*inExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeIn(expr *inExpr) GroupID {
	const size = uint32(unsafe.Sizeof(inExpr{}))
	const align = uint32(unsafe.Alignof(inExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*inExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(InOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: InOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type notInExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *notInExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(notInExpr{})
	const offset = unsafe.Offsetof(notInExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asNotIn() *notInExpr {
	if m.op != NotInOp {
		return nil
	}

	return (*notInExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeNotIn(expr *notInExpr) GroupID {
	const size = uint32(unsafe.Sizeof(notInExpr{}))
	const align = uint32(unsafe.Alignof(notInExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*notInExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(NotInOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: NotInOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type likeExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *likeExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(likeExpr{})
	const offset = unsafe.Offsetof(likeExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asLike() *likeExpr {
	if m.op != LikeOp {
		return nil
	}

	return (*likeExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeLike(expr *likeExpr) GroupID {
	const size = uint32(unsafe.Sizeof(likeExpr{}))
	const align = uint32(unsafe.Alignof(likeExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*likeExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(LikeOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: LikeOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type notLikeExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *notLikeExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(notLikeExpr{})
	const offset = unsafe.Offsetof(notLikeExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asNotLike() *notLikeExpr {
	if m.op != NotLikeOp {
		return nil
	}

	return (*notLikeExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeNotLike(expr *notLikeExpr) GroupID {
	const size = uint32(unsafe.Sizeof(notLikeExpr{}))
	const align = uint32(unsafe.Alignof(notLikeExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*notLikeExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(NotLikeOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: NotLikeOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type iLikeExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *iLikeExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(iLikeExpr{})
	const offset = unsafe.Offsetof(iLikeExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asILike() *iLikeExpr {
	if m.op != ILikeOp {
		return nil
	}

	return (*iLikeExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeILike(expr *iLikeExpr) GroupID {
	const size = uint32(unsafe.Sizeof(iLikeExpr{}))
	const align = uint32(unsafe.Alignof(iLikeExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*iLikeExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ILikeOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ILikeOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type notILikeExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *notILikeExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(notILikeExpr{})
	const offset = unsafe.Offsetof(notILikeExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asNotILike() *notILikeExpr {
	if m.op != NotILikeOp {
		return nil
	}

	return (*notILikeExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeNotILike(expr *notILikeExpr) GroupID {
	const size = uint32(unsafe.Sizeof(notILikeExpr{}))
	const align = uint32(unsafe.Alignof(notILikeExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*notILikeExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(NotILikeOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: NotILikeOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type similarToExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *similarToExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(similarToExpr{})
	const offset = unsafe.Offsetof(similarToExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asSimilarTo() *similarToExpr {
	if m.op != SimilarToOp {
		return nil
	}

	return (*similarToExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeSimilarTo(expr *similarToExpr) GroupID {
	const size = uint32(unsafe.Sizeof(similarToExpr{}))
	const align = uint32(unsafe.Alignof(similarToExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*similarToExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(SimilarToOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: SimilarToOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type notSimilarToExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *notSimilarToExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(notSimilarToExpr{})
	const offset = unsafe.Offsetof(notSimilarToExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asNotSimilarTo() *notSimilarToExpr {
	if m.op != NotSimilarToOp {
		return nil
	}

	return (*notSimilarToExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeNotSimilarTo(expr *notSimilarToExpr) GroupID {
	const size = uint32(unsafe.Sizeof(notSimilarToExpr{}))
	const align = uint32(unsafe.Alignof(notSimilarToExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*notSimilarToExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(NotSimilarToOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: NotSimilarToOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type regMatchExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *regMatchExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(regMatchExpr{})
	const offset = unsafe.Offsetof(regMatchExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asRegMatch() *regMatchExpr {
	if m.op != RegMatchOp {
		return nil
	}

	return (*regMatchExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeRegMatch(expr *regMatchExpr) GroupID {
	const size = uint32(unsafe.Sizeof(regMatchExpr{}))
	const align = uint32(unsafe.Alignof(regMatchExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*regMatchExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(RegMatchOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: RegMatchOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type notRegMatchExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *notRegMatchExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(notRegMatchExpr{})
	const offset = unsafe.Offsetof(notRegMatchExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asNotRegMatch() *notRegMatchExpr {
	if m.op != NotRegMatchOp {
		return nil
	}

	return (*notRegMatchExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeNotRegMatch(expr *notRegMatchExpr) GroupID {
	const size = uint32(unsafe.Sizeof(notRegMatchExpr{}))
	const align = uint32(unsafe.Alignof(notRegMatchExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*notRegMatchExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(NotRegMatchOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: NotRegMatchOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type regIMatchExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *regIMatchExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(regIMatchExpr{})
	const offset = unsafe.Offsetof(regIMatchExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asRegIMatch() *regIMatchExpr {
	if m.op != RegIMatchOp {
		return nil
	}

	return (*regIMatchExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeRegIMatch(expr *regIMatchExpr) GroupID {
	const size = uint32(unsafe.Sizeof(regIMatchExpr{}))
	const align = uint32(unsafe.Alignof(regIMatchExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*regIMatchExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(RegIMatchOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: RegIMatchOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type notRegIMatchExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *notRegIMatchExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(notRegIMatchExpr{})
	const offset = unsafe.Offsetof(notRegIMatchExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asNotRegIMatch() *notRegIMatchExpr {
	if m.op != NotRegIMatchOp {
		return nil
	}

	return (*notRegIMatchExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeNotRegIMatch(expr *notRegIMatchExpr) GroupID {
	const size = uint32(unsafe.Sizeof(notRegIMatchExpr{}))
	const align = uint32(unsafe.Alignof(notRegIMatchExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*notRegIMatchExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(NotRegIMatchOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: NotRegIMatchOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type isDistinctFromExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *isDistinctFromExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(isDistinctFromExpr{})
	const offset = unsafe.Offsetof(isDistinctFromExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asIsDistinctFrom() *isDistinctFromExpr {
	if m.op != IsDistinctFromOp {
		return nil
	}

	return (*isDistinctFromExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeIsDistinctFrom(expr *isDistinctFromExpr) GroupID {
	const size = uint32(unsafe.Sizeof(isDistinctFromExpr{}))
	const align = uint32(unsafe.Alignof(isDistinctFromExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*isDistinctFromExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(IsDistinctFromOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: IsDistinctFromOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type isNotDistinctFromExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *isNotDistinctFromExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(isNotDistinctFromExpr{})
	const offset = unsafe.Offsetof(isNotDistinctFromExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asIsNotDistinctFrom() *isNotDistinctFromExpr {
	if m.op != IsNotDistinctFromOp {
		return nil
	}

	return (*isNotDistinctFromExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeIsNotDistinctFrom(expr *isNotDistinctFromExpr) GroupID {
	const size = uint32(unsafe.Sizeof(isNotDistinctFromExpr{}))
	const align = uint32(unsafe.Alignof(isNotDistinctFromExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*isNotDistinctFromExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(IsNotDistinctFromOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: IsNotDistinctFromOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type isExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *isExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(isExpr{})
	const offset = unsafe.Offsetof(isExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asIs() *isExpr {
	if m.op != IsOp {
		return nil
	}

	return (*isExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeIs(expr *isExpr) GroupID {
	const size = uint32(unsafe.Sizeof(isExpr{}))
	const align = uint32(unsafe.Alignof(isExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*isExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(IsOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: IsOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type isNotExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *isNotExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(isNotExpr{})
	const offset = unsafe.Offsetof(isNotExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asIsNot() *isNotExpr {
	if m.op != IsNotOp {
		return nil
	}

	return (*isNotExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeIsNot(expr *isNotExpr) GroupID {
	const size = uint32(unsafe.Sizeof(isNotExpr{}))
	const align = uint32(unsafe.Alignof(isNotExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*isNotExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(IsNotOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: IsNotOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type anyExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *anyExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(anyExpr{})
	const offset = unsafe.Offsetof(anyExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asAny() *anyExpr {
	if m.op != AnyOp {
		return nil
	}

	return (*anyExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeAny(expr *anyExpr) GroupID {
	const size = uint32(unsafe.Sizeof(anyExpr{}))
	const align = uint32(unsafe.Alignof(anyExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*anyExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(AnyOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: AnyOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type someExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *someExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(someExpr{})
	const offset = unsafe.Offsetof(someExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asSome() *someExpr {
	if m.op != SomeOp {
		return nil
	}

	return (*someExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeSome(expr *someExpr) GroupID {
	const size = uint32(unsafe.Sizeof(someExpr{}))
	const align = uint32(unsafe.Alignof(someExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*someExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(SomeOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: SomeOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type allExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *allExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(allExpr{})
	const offset = unsafe.Offsetof(allExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asAll() *allExpr {
	if m.op != AllOp {
		return nil
	}

	return (*allExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeAll(expr *allExpr) GroupID {
	const size = uint32(unsafe.Sizeof(allExpr{}))
	const align = uint32(unsafe.Alignof(allExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*allExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(AllOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: AllOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type bitandExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *bitandExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(bitandExpr{})
	const offset = unsafe.Offsetof(bitandExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asBitand() *bitandExpr {
	if m.op != BitandOp {
		return nil
	}

	return (*bitandExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeBitand(expr *bitandExpr) GroupID {
	const size = uint32(unsafe.Sizeof(bitandExpr{}))
	const align = uint32(unsafe.Alignof(bitandExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*bitandExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(BitandOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: BitandOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type bitorExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *bitorExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(bitorExpr{})
	const offset = unsafe.Offsetof(bitorExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asBitor() *bitorExpr {
	if m.op != BitorOp {
		return nil
	}

	return (*bitorExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeBitor(expr *bitorExpr) GroupID {
	const size = uint32(unsafe.Sizeof(bitorExpr{}))
	const align = uint32(unsafe.Alignof(bitorExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*bitorExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(BitorOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: BitorOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type bitxorExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *bitxorExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(bitxorExpr{})
	const offset = unsafe.Offsetof(bitxorExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asBitxor() *bitxorExpr {
	if m.op != BitxorOp {
		return nil
	}

	return (*bitxorExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeBitxor(expr *bitxorExpr) GroupID {
	const size = uint32(unsafe.Sizeof(bitxorExpr{}))
	const align = uint32(unsafe.Alignof(bitxorExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*bitxorExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(BitxorOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: BitxorOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type plusExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *plusExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(plusExpr{})
	const offset = unsafe.Offsetof(plusExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asPlus() *plusExpr {
	if m.op != PlusOp {
		return nil
	}

	return (*plusExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizePlus(expr *plusExpr) GroupID {
	const size = uint32(unsafe.Sizeof(plusExpr{}))
	const align = uint32(unsafe.Alignof(plusExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*plusExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(PlusOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: PlusOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type minusExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *minusExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(minusExpr{})
	const offset = unsafe.Offsetof(minusExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asMinus() *minusExpr {
	if m.op != MinusOp {
		return nil
	}

	return (*minusExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeMinus(expr *minusExpr) GroupID {
	const size = uint32(unsafe.Sizeof(minusExpr{}))
	const align = uint32(unsafe.Alignof(minusExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*minusExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(MinusOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: MinusOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type multExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *multExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(multExpr{})
	const offset = unsafe.Offsetof(multExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asMult() *multExpr {
	if m.op != MultOp {
		return nil
	}

	return (*multExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeMult(expr *multExpr) GroupID {
	const size = uint32(unsafe.Sizeof(multExpr{}))
	const align = uint32(unsafe.Alignof(multExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*multExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(MultOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: MultOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type divExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *divExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(divExpr{})
	const offset = unsafe.Offsetof(divExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asDiv() *divExpr {
	if m.op != DivOp {
		return nil
	}

	return (*divExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeDiv(expr *divExpr) GroupID {
	const size = uint32(unsafe.Sizeof(divExpr{}))
	const align = uint32(unsafe.Alignof(divExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*divExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(DivOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: DivOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type floorDivExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *floorDivExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(floorDivExpr{})
	const offset = unsafe.Offsetof(floorDivExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asFloorDiv() *floorDivExpr {
	if m.op != FloorDivOp {
		return nil
	}

	return (*floorDivExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeFloorDiv(expr *floorDivExpr) GroupID {
	const size = uint32(unsafe.Sizeof(floorDivExpr{}))
	const align = uint32(unsafe.Alignof(floorDivExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*floorDivExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(FloorDivOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: FloorDivOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type modExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *modExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(modExpr{})
	const offset = unsafe.Offsetof(modExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asMod() *modExpr {
	if m.op != ModOp {
		return nil
	}

	return (*modExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeMod(expr *modExpr) GroupID {
	const size = uint32(unsafe.Sizeof(modExpr{}))
	const align = uint32(unsafe.Alignof(modExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*modExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ModOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ModOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type powExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *powExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(powExpr{})
	const offset = unsafe.Offsetof(powExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asPow() *powExpr {
	if m.op != PowOp {
		return nil
	}

	return (*powExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizePow(expr *powExpr) GroupID {
	const size = uint32(unsafe.Sizeof(powExpr{}))
	const align = uint32(unsafe.Alignof(powExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*powExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(PowOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: PowOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type concatExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *concatExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(concatExpr{})
	const offset = unsafe.Offsetof(concatExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asConcat() *concatExpr {
	if m.op != ConcatOp {
		return nil
	}

	return (*concatExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeConcat(expr *concatExpr) GroupID {
	const size = uint32(unsafe.Sizeof(concatExpr{}))
	const align = uint32(unsafe.Alignof(concatExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*concatExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ConcatOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ConcatOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type lShiftExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *lShiftExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(lShiftExpr{})
	const offset = unsafe.Offsetof(lShiftExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asLShift() *lShiftExpr {
	if m.op != LShiftOp {
		return nil
	}

	return (*lShiftExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeLShift(expr *lShiftExpr) GroupID {
	const size = uint32(unsafe.Sizeof(lShiftExpr{}))
	const align = uint32(unsafe.Alignof(lShiftExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*lShiftExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(LShiftOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: LShiftOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type rShiftExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *rShiftExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(rShiftExpr{})
	const offset = unsafe.Offsetof(rShiftExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asRShift() *rShiftExpr {
	if m.op != RShiftOp {
		return nil
	}

	return (*rShiftExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeRShift(expr *rShiftExpr) GroupID {
	const size = uint32(unsafe.Sizeof(rShiftExpr{}))
	const align = uint32(unsafe.Alignof(rShiftExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*rShiftExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(RShiftOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: RShiftOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type unaryPlusExpr struct {
	memoExpr
	input GroupID
}

func (e *unaryPlusExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(unaryPlusExpr{})
	const offset = unsafe.Offsetof(unaryPlusExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asUnaryPlus() *unaryPlusExpr {
	if m.op != UnaryPlusOp {
		return nil
	}

	return (*unaryPlusExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeUnaryPlus(expr *unaryPlusExpr) GroupID {
	const size = uint32(unsafe.Sizeof(unaryPlusExpr{}))
	const align = uint32(unsafe.Alignof(unaryPlusExpr{}))

	if expr.input == 0 {
		panic("input child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*unaryPlusExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(UnaryPlusOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: UnaryPlusOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type unaryMinusExpr struct {
	memoExpr
	input GroupID
}

func (e *unaryMinusExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(unaryMinusExpr{})
	const offset = unsafe.Offsetof(unaryMinusExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asUnaryMinus() *unaryMinusExpr {
	if m.op != UnaryMinusOp {
		return nil
	}

	return (*unaryMinusExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeUnaryMinus(expr *unaryMinusExpr) GroupID {
	const size = uint32(unsafe.Sizeof(unaryMinusExpr{}))
	const align = uint32(unsafe.Alignof(unaryMinusExpr{}))

	if expr.input == 0 {
		panic("input child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*unaryMinusExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(UnaryMinusOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: UnaryMinusOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type unaryComplementExpr struct {
	memoExpr
	input GroupID
}

func (e *unaryComplementExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(unaryComplementExpr{})
	const offset = unsafe.Offsetof(unaryComplementExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asUnaryComplement() *unaryComplementExpr {
	if m.op != UnaryComplementOp {
		return nil
	}

	return (*unaryComplementExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeUnaryComplement(expr *unaryComplementExpr) GroupID {
	const size = uint32(unsafe.Sizeof(unaryComplementExpr{}))
	const align = uint32(unsafe.Alignof(unaryComplementExpr{}))

	if expr.input == 0 {
		panic("input child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*unaryComplementExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(UnaryComplementOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: UnaryComplementOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type functionExpr struct {
	memoExpr
	args ListID
	def  PrivateID
}

func (e *functionExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(functionExpr{})
	const offset = unsafe.Offsetof(functionExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asFunction() *functionExpr {
	if m.op != FunctionOp {
		return nil
	}

	return (*functionExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeFunction(expr *functionExpr) GroupID {
	const size = uint32(unsafe.Sizeof(functionExpr{}))
	const align = uint32(unsafe.Alignof(functionExpr{}))

	if expr.args == UndefinedList {
		panic("args child cannot be undefined")
	}

	if expr.def == 0 {
		panic("def child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*functionExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(FunctionOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: FunctionOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type trueExpr struct {
	memoExpr
}

func (e *trueExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(trueExpr{})
	const offset = unsafe.Offsetof(trueExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asTrue() *trueExpr {
	if m.op != TrueOp {
		return nil
	}

	return (*trueExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeTrue(expr *trueExpr) GroupID {
	const size = uint32(unsafe.Sizeof(trueExpr{}))
	const align = uint32(unsafe.Alignof(trueExpr{}))

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*trueExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(TrueOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: TrueOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type falseExpr struct {
	memoExpr
}

func (e *falseExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(falseExpr{})
	const offset = unsafe.Offsetof(falseExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asFalse() *falseExpr {
	if m.op != FalseOp {
		return nil
	}

	return (*falseExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeFalse(expr *falseExpr) GroupID {
	const size = uint32(unsafe.Sizeof(falseExpr{}))
	const align = uint32(unsafe.Alignof(falseExpr{}))

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*falseExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(FalseOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: FalseOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type scanExpr struct {
	memoExpr
	table PrivateID
}

func (e *scanExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(scanExpr{})
	const offset = unsafe.Offsetof(scanExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asScan() *scanExpr {
	if m.op != ScanOp {
		return nil
	}

	return (*scanExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeScan(expr *scanExpr) GroupID {
	const size = uint32(unsafe.Sizeof(scanExpr{}))
	const align = uint32(unsafe.Alignof(scanExpr{}))

	if expr.table == 0 {
		panic("table child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*scanExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ScanOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ScanOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type valuesExpr struct {
	memoExpr
}

func (e *valuesExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(valuesExpr{})
	const offset = unsafe.Offsetof(valuesExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asValues() *valuesExpr {
	if m.op != ValuesOp {
		return nil
	}

	return (*valuesExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeValues(expr *valuesExpr) GroupID {
	const size = uint32(unsafe.Sizeof(valuesExpr{}))
	const align = uint32(unsafe.Alignof(valuesExpr{}))

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*valuesExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ValuesOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ValuesOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type selectExpr struct {
	memoExpr
	input  GroupID
	filter GroupID
}

func (e *selectExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(selectExpr{})
	const offset = unsafe.Offsetof(selectExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asSelect() *selectExpr {
	if m.op != SelectOp {
		return nil
	}

	return (*selectExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeSelect(expr *selectExpr) GroupID {
	const size = uint32(unsafe.Sizeof(selectExpr{}))
	const align = uint32(unsafe.Alignof(selectExpr{}))

	if expr.input == 0 {
		panic("input child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*selectExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(SelectOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: SelectOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type projectExpr struct {
	memoExpr
	input       GroupID
	projections GroupID
}

func (e *projectExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(projectExpr{})
	const offset = unsafe.Offsetof(projectExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asProject() *projectExpr {
	if m.op != ProjectOp {
		return nil
	}

	return (*projectExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeProject(expr *projectExpr) GroupID {
	const size = uint32(unsafe.Sizeof(projectExpr{}))
	const align = uint32(unsafe.Alignof(projectExpr{}))

	if expr.input == 0 {
		panic("input child cannot be undefined")
	}

	if expr.projections == 0 {
		panic("projections child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*projectExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ProjectOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ProjectOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type innerJoinExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *innerJoinExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(innerJoinExpr{})
	const offset = unsafe.Offsetof(innerJoinExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asInnerJoin() *innerJoinExpr {
	if m.op != InnerJoinOp {
		return nil
	}

	return (*innerJoinExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeInnerJoin(expr *innerJoinExpr) GroupID {
	const size = uint32(unsafe.Sizeof(innerJoinExpr{}))
	const align = uint32(unsafe.Alignof(innerJoinExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*innerJoinExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(InnerJoinOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: InnerJoinOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type leftJoinExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *leftJoinExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(leftJoinExpr{})
	const offset = unsafe.Offsetof(leftJoinExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asLeftJoin() *leftJoinExpr {
	if m.op != LeftJoinOp {
		return nil
	}

	return (*leftJoinExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeLeftJoin(expr *leftJoinExpr) GroupID {
	const size = uint32(unsafe.Sizeof(leftJoinExpr{}))
	const align = uint32(unsafe.Alignof(leftJoinExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*leftJoinExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(LeftJoinOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: LeftJoinOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type rightJoinExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *rightJoinExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(rightJoinExpr{})
	const offset = unsafe.Offsetof(rightJoinExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asRightJoin() *rightJoinExpr {
	if m.op != RightJoinOp {
		return nil
	}

	return (*rightJoinExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeRightJoin(expr *rightJoinExpr) GroupID {
	const size = uint32(unsafe.Sizeof(rightJoinExpr{}))
	const align = uint32(unsafe.Alignof(rightJoinExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*rightJoinExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(RightJoinOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: RightJoinOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type fullJoinExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *fullJoinExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(fullJoinExpr{})
	const offset = unsafe.Offsetof(fullJoinExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asFullJoin() *fullJoinExpr {
	if m.op != FullJoinOp {
		return nil
	}

	return (*fullJoinExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeFullJoin(expr *fullJoinExpr) GroupID {
	const size = uint32(unsafe.Sizeof(fullJoinExpr{}))
	const align = uint32(unsafe.Alignof(fullJoinExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*fullJoinExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(FullJoinOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: FullJoinOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type semiJoinExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *semiJoinExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(semiJoinExpr{})
	const offset = unsafe.Offsetof(semiJoinExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asSemiJoin() *semiJoinExpr {
	if m.op != SemiJoinOp {
		return nil
	}

	return (*semiJoinExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeSemiJoin(expr *semiJoinExpr) GroupID {
	const size = uint32(unsafe.Sizeof(semiJoinExpr{}))
	const align = uint32(unsafe.Alignof(semiJoinExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*semiJoinExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(SemiJoinOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: SemiJoinOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type antiJoinExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *antiJoinExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(antiJoinExpr{})
	const offset = unsafe.Offsetof(antiJoinExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asAntiJoin() *antiJoinExpr {
	if m.op != AntiJoinOp {
		return nil
	}

	return (*antiJoinExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeAntiJoin(expr *antiJoinExpr) GroupID {
	const size = uint32(unsafe.Sizeof(antiJoinExpr{}))
	const align = uint32(unsafe.Alignof(antiJoinExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*antiJoinExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(AntiJoinOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: AntiJoinOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type innerJoinApplyExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *innerJoinApplyExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(innerJoinApplyExpr{})
	const offset = unsafe.Offsetof(innerJoinApplyExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asInnerJoinApply() *innerJoinApplyExpr {
	if m.op != InnerJoinApplyOp {
		return nil
	}

	return (*innerJoinApplyExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeInnerJoinApply(expr *innerJoinApplyExpr) GroupID {
	const size = uint32(unsafe.Sizeof(innerJoinApplyExpr{}))
	const align = uint32(unsafe.Alignof(innerJoinApplyExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*innerJoinApplyExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(InnerJoinApplyOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: InnerJoinApplyOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type leftJoinApplyExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *leftJoinApplyExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(leftJoinApplyExpr{})
	const offset = unsafe.Offsetof(leftJoinApplyExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asLeftJoinApply() *leftJoinApplyExpr {
	if m.op != LeftJoinApplyOp {
		return nil
	}

	return (*leftJoinApplyExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeLeftJoinApply(expr *leftJoinApplyExpr) GroupID {
	const size = uint32(unsafe.Sizeof(leftJoinApplyExpr{}))
	const align = uint32(unsafe.Alignof(leftJoinApplyExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*leftJoinApplyExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(LeftJoinApplyOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: LeftJoinApplyOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type rightJoinApplyExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *rightJoinApplyExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(rightJoinApplyExpr{})
	const offset = unsafe.Offsetof(rightJoinApplyExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asRightJoinApply() *rightJoinApplyExpr {
	if m.op != RightJoinApplyOp {
		return nil
	}

	return (*rightJoinApplyExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeRightJoinApply(expr *rightJoinApplyExpr) GroupID {
	const size = uint32(unsafe.Sizeof(rightJoinApplyExpr{}))
	const align = uint32(unsafe.Alignof(rightJoinApplyExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*rightJoinApplyExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(RightJoinApplyOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: RightJoinApplyOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type fullJoinApplyExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *fullJoinApplyExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(fullJoinApplyExpr{})
	const offset = unsafe.Offsetof(fullJoinApplyExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asFullJoinApply() *fullJoinApplyExpr {
	if m.op != FullJoinApplyOp {
		return nil
	}

	return (*fullJoinApplyExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeFullJoinApply(expr *fullJoinApplyExpr) GroupID {
	const size = uint32(unsafe.Sizeof(fullJoinApplyExpr{}))
	const align = uint32(unsafe.Alignof(fullJoinApplyExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*fullJoinApplyExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(FullJoinApplyOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: FullJoinApplyOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type semiJoinApplyExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *semiJoinApplyExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(semiJoinApplyExpr{})
	const offset = unsafe.Offsetof(semiJoinApplyExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asSemiJoinApply() *semiJoinApplyExpr {
	if m.op != SemiJoinApplyOp {
		return nil
	}

	return (*semiJoinApplyExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeSemiJoinApply(expr *semiJoinApplyExpr) GroupID {
	const size = uint32(unsafe.Sizeof(semiJoinApplyExpr{}))
	const align = uint32(unsafe.Alignof(semiJoinApplyExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*semiJoinApplyExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(SemiJoinApplyOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: SemiJoinApplyOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type antiJoinApplyExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	filter GroupID
}

func (e *antiJoinApplyExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(antiJoinApplyExpr{})
	const offset = unsafe.Offsetof(antiJoinApplyExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asAntiJoinApply() *antiJoinApplyExpr {
	if m.op != AntiJoinApplyOp {
		return nil
	}

	return (*antiJoinApplyExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeAntiJoinApply(expr *antiJoinApplyExpr) GroupID {
	const size = uint32(unsafe.Sizeof(antiJoinApplyExpr{}))
	const align = uint32(unsafe.Alignof(antiJoinApplyExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.filter == 0 {
		panic("filter child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*antiJoinApplyExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(AntiJoinApplyOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: AntiJoinApplyOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type groupByExpr struct {
	memoExpr
	input        GroupID
	groupings    GroupID
	aggregations GroupID
}

func (e *groupByExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(groupByExpr{})
	const offset = unsafe.Offsetof(groupByExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asGroupBy() *groupByExpr {
	if m.op != GroupByOp {
		return nil
	}

	return (*groupByExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeGroupBy(expr *groupByExpr) GroupID {
	const size = uint32(unsafe.Sizeof(groupByExpr{}))
	const align = uint32(unsafe.Alignof(groupByExpr{}))

	if expr.input == 0 {
		panic("input child cannot be undefined")
	}

	if expr.groupings == 0 {
		panic("groupings child cannot be undefined")
	}

	if expr.aggregations == 0 {
		panic("aggregations child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*groupByExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(GroupByOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: GroupByOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type unionExpr struct {
	memoExpr
	left   GroupID
	right  GroupID
	colMap PrivateID
}

func (e *unionExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(unionExpr{})
	const offset = unsafe.Offsetof(unionExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asUnion() *unionExpr {
	if m.op != UnionOp {
		return nil
	}

	return (*unionExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeUnion(expr *unionExpr) GroupID {
	const size = uint32(unsafe.Sizeof(unionExpr{}))
	const align = uint32(unsafe.Alignof(unionExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	if expr.colMap == 0 {
		panic("colMap child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*unionExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(UnionOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: UnionOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type intersectExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *intersectExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(intersectExpr{})
	const offset = unsafe.Offsetof(intersectExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asIntersect() *intersectExpr {
	if m.op != IntersectOp {
		return nil
	}

	return (*intersectExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeIntersect(expr *intersectExpr) GroupID {
	const size = uint32(unsafe.Sizeof(intersectExpr{}))
	const align = uint32(unsafe.Alignof(intersectExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*intersectExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(IntersectOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: IntersectOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}

type exceptExpr struct {
	memoExpr
	left  GroupID
	right GroupID
}

func (e *exceptExpr) fingerprint() (f fingerprint) {
	const size = unsafe.Sizeof(exceptExpr{})
	const offset = unsafe.Offsetof(exceptExpr{}.op)

	b := *(*[size]byte)(unsafe.Pointer(e))

	if size-offset <= unsafe.Sizeof(f) {
		copy(f[:], b[offset:])
	} else {
		f = fingerprint(md5.Sum(b[offset:]))
	}

	return
}

func (m *memoExpr) asExcept() *exceptExpr {
	if m.op != ExceptOp {
		return nil
	}

	return (*exceptExpr)(unsafe.Pointer(m))
}

func (m *memo) memoizeExcept(expr *exceptExpr) GroupID {
	const size = uint32(unsafe.Sizeof(exceptExpr{}))
	const align = uint32(unsafe.Alignof(exceptExpr{}))

	if expr.left == 0 {
		panic("left child cannot be undefined")
	}

	if expr.right == 0 {
		panic("right child cannot be undefined")
	}

	fingerprint := expr.fingerprint()
	loc := m.exprMap[fingerprint]
	if loc.offset == 0 {
		loc.offset = exprOffset(m.arena.alloc(size, align))
		p := (*exceptExpr)(m.arena.getPointer(uint32(loc.offset)))
		*p = *expr

		if loc.group == 0 {
			if expr.group != 0 {
				loc.group = expr.group
			} else {
				mgrp := m.newGroup(ExceptOp, loc.offset)
				p.group = mgrp.id
				loc.group = mgrp.id
				e := Expr{mem: m, group: mgrp.id, op: ExceptOp, offset: loc.offset, required: defaultPhysPropsID}
				mgrp.logical = m.logPropsFactory.constructProps(&e)
			}
		} else {
			if expr.group != loc.group {
				panic("denormalized expression's group doesn't match fingerprint group")
			}
		}

		m.lookupGroup(loc.group).addExpr(loc.offset)
		m.exprMap[fingerprint] = loc
	}

	return loc.group
}
