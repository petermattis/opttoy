// Code generated by optgen; DO NOT EDIT.

package opt

func (_f *Factory) ConstructSubquery(
	input GroupID,
	projection GroupID,
) GroupID {
	_subqueryExpr := subqueryExpr{memoExpr: memoExpr{op: SubqueryOp}, input: input, projection: projection}
	_fingerprint := _subqueryExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeSubquery(&_subqueryExpr))
}

func (_f *Factory) ConstructVariable(
	col PrivateID,
) GroupID {
	_variableExpr := variableExpr{memoExpr: memoExpr{op: VariableOp}, col: col}
	_fingerprint := _variableExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeVariable(&_variableExpr))
}

func (_f *Factory) ConstructConst(
	value PrivateID,
) GroupID {
	_constExpr := constExpr{memoExpr: memoExpr{op: ConstOp}, value: value}
	_fingerprint := _constExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeConst(&_constExpr))
}

func (_f *Factory) ConstructPlaceholder(
	value PrivateID,
) GroupID {
	_placeholderExpr := placeholderExpr{memoExpr: memoExpr{op: PlaceholderOp}, value: value}
	_fingerprint := _placeholderExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizePlaceholder(&_placeholderExpr))
}

func (_f *Factory) ConstructList(
	items ListID,
) GroupID {
	_listExpr := listExpr{memoExpr: memoExpr{op: ListOp}, items: items}
	_fingerprint := _listExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeList(&_listExpr))
}

func (_f *Factory) ConstructOrderedList(
	items ListID,
) GroupID {
	_orderedListExpr := orderedListExpr{memoExpr: memoExpr{op: OrderedListOp}, items: items}
	_fingerprint := _orderedListExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeOrderedList(&_orderedListExpr))
}

func (_f *Factory) ConstructTuple(
	elems ListID,
) GroupID {
	_tupleExpr := tupleExpr{memoExpr: memoExpr{op: TupleOp}, elems: elems}
	_fingerprint := _tupleExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeTuple(&_tupleExpr))
}

func (_f *Factory) ConstructFilters(
	conditions ListID,
) GroupID {
	_filtersExpr := filtersExpr{memoExpr: memoExpr{op: FiltersOp}, conditions: conditions}
	_fingerprint := _filtersExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeFilters(&_filtersExpr)
	}

	// [EliminateFilters]
	{
		items := conditions
		if _f.isEmptyList(items) {
			_f.maxSteps--
			_group = _f.ConstructTrue()
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeFilters(&_filtersExpr))
}

func (_f *Factory) ConstructProjections(
	items ListID,
	cols PrivateID,
) GroupID {
	_projectionsExpr := projectionsExpr{memoExpr: memoExpr{op: ProjectionsOp}, items: items, cols: cols}
	_fingerprint := _projectionsExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeProjections(&_projectionsExpr))
}

func (_f *Factory) ConstructExists(
	input GroupID,
) GroupID {
	_existsExpr := existsExpr{memoExpr: memoExpr{op: ExistsOp}, input: input}
	_fingerprint := _existsExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeExists(&_existsExpr))
}

func (_f *Factory) ConstructAnd(
	left GroupID,
	right GroupID,
) GroupID {
	_andExpr := andExpr{memoExpr: memoExpr{op: AndOp}, left: left, right: right}
	_fingerprint := _andExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeAnd(&_andExpr))
}

func (_f *Factory) ConstructOr(
	left GroupID,
	right GroupID,
) GroupID {
	_orExpr := orExpr{memoExpr: memoExpr{op: OrOp}, left: left, right: right}
	_fingerprint := _orExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeOr(&_orExpr))
}

func (_f *Factory) ConstructNot(
	input GroupID,
) GroupID {
	_notExpr := notExpr{memoExpr: memoExpr{op: NotOp}, input: input}
	_fingerprint := _notExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNot(&_notExpr))
}

func (_f *Factory) ConstructEq(
	left GroupID,
	right GroupID,
) GroupID {
	_eqExpr := eqExpr{memoExpr: memoExpr{op: EqOp}, left: left, right: right}
	_fingerprint := _eqExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeEq(&_eqExpr)
	}

	// [NormalizeVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.maxSteps--
				_group = _f.ConstructEq(right, left)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [NormalizeVarOrder]
	{
		_variable3 := _f.mem.lookupNormExpr(left).asVariable()
		if _variable3 != nil {
			_variable4 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable4 != nil {
				if _f.isLowerExpr(right, left) {
					_f.maxSteps--
					_group = _f.ConstructEq(right, left)
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeEq(&_eqExpr))
}

func (_f *Factory) ConstructLt(
	left GroupID,
	right GroupID,
) GroupID {
	_ltExpr := ltExpr{memoExpr: memoExpr{op: LtOp}, left: left, right: right}
	_fingerprint := _ltExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeLt(&_ltExpr))
}

func (_f *Factory) ConstructGt(
	left GroupID,
	right GroupID,
) GroupID {
	_gtExpr := gtExpr{memoExpr: memoExpr{op: GtOp}, left: left, right: right}
	_fingerprint := _gtExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeGt(&_gtExpr))
}

func (_f *Factory) ConstructLe(
	left GroupID,
	right GroupID,
) GroupID {
	_leExpr := leExpr{memoExpr: memoExpr{op: LeOp}, left: left, right: right}
	_fingerprint := _leExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeLe(&_leExpr))
}

func (_f *Factory) ConstructGe(
	left GroupID,
	right GroupID,
) GroupID {
	_geExpr := geExpr{memoExpr: memoExpr{op: GeOp}, left: left, right: right}
	_fingerprint := _geExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeGe(&_geExpr))
}

func (_f *Factory) ConstructNe(
	left GroupID,
	right GroupID,
) GroupID {
	_neExpr := neExpr{memoExpr: memoExpr{op: NeOp}, left: left, right: right}
	_fingerprint := _neExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeNe(&_neExpr)
	}

	// [NormalizeVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.maxSteps--
				_group = _f.ConstructNe(right, left)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [NormalizeVarOrder]
	{
		_variable3 := _f.mem.lookupNormExpr(left).asVariable()
		if _variable3 != nil {
			_variable4 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable4 != nil {
				if _f.isLowerExpr(right, left) {
					_f.maxSteps--
					_group = _f.ConstructNe(right, left)
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNe(&_neExpr))
}

func (_f *Factory) ConstructIn(
	left GroupID,
	right GroupID,
) GroupID {
	_inExpr := inExpr{memoExpr: memoExpr{op: InOp}, left: left, right: right}
	_fingerprint := _inExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIn(&_inExpr))
}

func (_f *Factory) ConstructNotIn(
	left GroupID,
	right GroupID,
) GroupID {
	_notInExpr := notInExpr{memoExpr: memoExpr{op: NotInOp}, left: left, right: right}
	_fingerprint := _notInExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotIn(&_notInExpr))
}

func (_f *Factory) ConstructLike(
	left GroupID,
	right GroupID,
) GroupID {
	_likeExpr := likeExpr{memoExpr: memoExpr{op: LikeOp}, left: left, right: right}
	_fingerprint := _likeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeLike(&_likeExpr))
}

func (_f *Factory) ConstructNotLike(
	left GroupID,
	right GroupID,
) GroupID {
	_notLikeExpr := notLikeExpr{memoExpr: memoExpr{op: NotLikeOp}, left: left, right: right}
	_fingerprint := _notLikeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotLike(&_notLikeExpr))
}

func (_f *Factory) ConstructILike(
	left GroupID,
	right GroupID,
) GroupID {
	_iLikeExpr := iLikeExpr{memoExpr: memoExpr{op: ILikeOp}, left: left, right: right}
	_fingerprint := _iLikeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeILike(&_iLikeExpr))
}

func (_f *Factory) ConstructNotILike(
	left GroupID,
	right GroupID,
) GroupID {
	_notILikeExpr := notILikeExpr{memoExpr: memoExpr{op: NotILikeOp}, left: left, right: right}
	_fingerprint := _notILikeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotILike(&_notILikeExpr))
}

func (_f *Factory) ConstructSimilarTo(
	left GroupID,
	right GroupID,
) GroupID {
	_similarToExpr := similarToExpr{memoExpr: memoExpr{op: SimilarToOp}, left: left, right: right}
	_fingerprint := _similarToExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeSimilarTo(&_similarToExpr))
}

func (_f *Factory) ConstructNotSimilarTo(
	left GroupID,
	right GroupID,
) GroupID {
	_notSimilarToExpr := notSimilarToExpr{memoExpr: memoExpr{op: NotSimilarToOp}, left: left, right: right}
	_fingerprint := _notSimilarToExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotSimilarTo(&_notSimilarToExpr))
}

func (_f *Factory) ConstructRegMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_regMatchExpr := regMatchExpr{memoExpr: memoExpr{op: RegMatchOp}, left: left, right: right}
	_fingerprint := _regMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeRegMatch(&_regMatchExpr))
}

func (_f *Factory) ConstructNotRegMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_notRegMatchExpr := notRegMatchExpr{memoExpr: memoExpr{op: NotRegMatchOp}, left: left, right: right}
	_fingerprint := _notRegMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotRegMatch(&_notRegMatchExpr))
}

func (_f *Factory) ConstructRegIMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_regIMatchExpr := regIMatchExpr{memoExpr: memoExpr{op: RegIMatchOp}, left: left, right: right}
	_fingerprint := _regIMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeRegIMatch(&_regIMatchExpr))
}

func (_f *Factory) ConstructNotRegIMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_notRegIMatchExpr := notRegIMatchExpr{memoExpr: memoExpr{op: NotRegIMatchOp}, left: left, right: right}
	_fingerprint := _notRegIMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotRegIMatch(&_notRegIMatchExpr))
}

func (_f *Factory) ConstructIsDistinctFrom(
	left GroupID,
	right GroupID,
) GroupID {
	_isDistinctFromExpr := isDistinctFromExpr{memoExpr: memoExpr{op: IsDistinctFromOp}, left: left, right: right}
	_fingerprint := _isDistinctFromExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIsDistinctFrom(&_isDistinctFromExpr))
}

func (_f *Factory) ConstructIsNotDistinctFrom(
	left GroupID,
	right GroupID,
) GroupID {
	_isNotDistinctFromExpr := isNotDistinctFromExpr{memoExpr: memoExpr{op: IsNotDistinctFromOp}, left: left, right: right}
	_fingerprint := _isNotDistinctFromExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIsNotDistinctFrom(&_isNotDistinctFromExpr))
}

func (_f *Factory) ConstructIs(
	left GroupID,
	right GroupID,
) GroupID {
	_isExpr := isExpr{memoExpr: memoExpr{op: IsOp}, left: left, right: right}
	_fingerprint := _isExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIs(&_isExpr))
}

func (_f *Factory) ConstructIsNot(
	left GroupID,
	right GroupID,
) GroupID {
	_isNotExpr := isNotExpr{memoExpr: memoExpr{op: IsNotOp}, left: left, right: right}
	_fingerprint := _isNotExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIsNot(&_isNotExpr))
}

func (_f *Factory) ConstructAny(
	left GroupID,
	right GroupID,
) GroupID {
	_anyExpr := anyExpr{memoExpr: memoExpr{op: AnyOp}, left: left, right: right}
	_fingerprint := _anyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeAny(&_anyExpr))
}

func (_f *Factory) ConstructSome(
	left GroupID,
	right GroupID,
) GroupID {
	_someExpr := someExpr{memoExpr: memoExpr{op: SomeOp}, left: left, right: right}
	_fingerprint := _someExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeSome(&_someExpr))
}

func (_f *Factory) ConstructAll(
	left GroupID,
	right GroupID,
) GroupID {
	_allExpr := allExpr{memoExpr: memoExpr{op: AllOp}, left: left, right: right}
	_fingerprint := _allExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeAll(&_allExpr))
}

func (_f *Factory) ConstructBitand(
	left GroupID,
	right GroupID,
) GroupID {
	_bitandExpr := bitandExpr{memoExpr: memoExpr{op: BitandOp}, left: left, right: right}
	_fingerprint := _bitandExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeBitand(&_bitandExpr))
}

func (_f *Factory) ConstructBitor(
	left GroupID,
	right GroupID,
) GroupID {
	_bitorExpr := bitorExpr{memoExpr: memoExpr{op: BitorOp}, left: left, right: right}
	_fingerprint := _bitorExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeBitor(&_bitorExpr))
}

func (_f *Factory) ConstructBitxor(
	left GroupID,
	right GroupID,
) GroupID {
	_bitxorExpr := bitxorExpr{memoExpr: memoExpr{op: BitxorOp}, left: left, right: right}
	_fingerprint := _bitxorExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeBitxor(&_bitxorExpr))
}

func (_f *Factory) ConstructPlus(
	left GroupID,
	right GroupID,
) GroupID {
	_plusExpr := plusExpr{memoExpr: memoExpr{op: PlusOp}, left: left, right: right}
	_fingerprint := _plusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizePlus(&_plusExpr))
}

func (_f *Factory) ConstructMinus(
	left GroupID,
	right GroupID,
) GroupID {
	_minusExpr := minusExpr{memoExpr: memoExpr{op: MinusOp}, left: left, right: right}
	_fingerprint := _minusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeMinus(&_minusExpr))
}

func (_f *Factory) ConstructMult(
	left GroupID,
	right GroupID,
) GroupID {
	_multExpr := multExpr{memoExpr: memoExpr{op: MultOp}, left: left, right: right}
	_fingerprint := _multExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeMult(&_multExpr))
}

func (_f *Factory) ConstructDiv(
	left GroupID,
	right GroupID,
) GroupID {
	_divExpr := divExpr{memoExpr: memoExpr{op: DivOp}, left: left, right: right}
	_fingerprint := _divExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeDiv(&_divExpr))
}

func (_f *Factory) ConstructFloorDiv(
	left GroupID,
	right GroupID,
) GroupID {
	_floorDivExpr := floorDivExpr{memoExpr: memoExpr{op: FloorDivOp}, left: left, right: right}
	_fingerprint := _floorDivExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeFloorDiv(&_floorDivExpr))
}

func (_f *Factory) ConstructMod(
	left GroupID,
	right GroupID,
) GroupID {
	_modExpr := modExpr{memoExpr: memoExpr{op: ModOp}, left: left, right: right}
	_fingerprint := _modExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeMod(&_modExpr))
}

func (_f *Factory) ConstructPow(
	left GroupID,
	right GroupID,
) GroupID {
	_powExpr := powExpr{memoExpr: memoExpr{op: PowOp}, left: left, right: right}
	_fingerprint := _powExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizePow(&_powExpr))
}

func (_f *Factory) ConstructConcat(
	left GroupID,
	right GroupID,
) GroupID {
	_concatExpr := concatExpr{memoExpr: memoExpr{op: ConcatOp}, left: left, right: right}
	_fingerprint := _concatExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeConcat(&_concatExpr))
}

func (_f *Factory) ConstructLShift(
	left GroupID,
	right GroupID,
) GroupID {
	_lShiftExpr := lShiftExpr{memoExpr: memoExpr{op: LShiftOp}, left: left, right: right}
	_fingerprint := _lShiftExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeLShift(&_lShiftExpr))
}

func (_f *Factory) ConstructRShift(
	left GroupID,
	right GroupID,
) GroupID {
	_rShiftExpr := rShiftExpr{memoExpr: memoExpr{op: RShiftOp}, left: left, right: right}
	_fingerprint := _rShiftExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeRShift(&_rShiftExpr))
}

func (_f *Factory) ConstructUnaryPlus(
	input GroupID,
) GroupID {
	_unaryPlusExpr := unaryPlusExpr{memoExpr: memoExpr{op: UnaryPlusOp}, input: input}
	_fingerprint := _unaryPlusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeUnaryPlus(&_unaryPlusExpr))
}

func (_f *Factory) ConstructUnaryMinus(
	input GroupID,
) GroupID {
	_unaryMinusExpr := unaryMinusExpr{memoExpr: memoExpr{op: UnaryMinusOp}, input: input}
	_fingerprint := _unaryMinusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeUnaryMinus(&_unaryMinusExpr))
}

func (_f *Factory) ConstructUnaryComplement(
	input GroupID,
) GroupID {
	_unaryComplementExpr := unaryComplementExpr{memoExpr: memoExpr{op: UnaryComplementOp}, input: input}
	_fingerprint := _unaryComplementExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeUnaryComplement(&_unaryComplementExpr))
}

func (_f *Factory) ConstructFunction(
	args ListID,
	def PrivateID,
) GroupID {
	_functionExpr := functionExpr{memoExpr: memoExpr{op: FunctionOp}, args: args, def: def}
	_fingerprint := _functionExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeFunction(&_functionExpr))
}

func (_f *Factory) ConstructTrue() GroupID {
	_trueExpr := trueExpr{memoExpr: memoExpr{op: TrueOp}}
	_fingerprint := _trueExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeTrue(&_trueExpr))
}

func (_f *Factory) ConstructFalse() GroupID {
	_falseExpr := falseExpr{memoExpr: memoExpr{op: FalseOp}}
	_fingerprint := _falseExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeFalse(&_falseExpr))
}

func (_f *Factory) ConstructScan(
	table PrivateID,
) GroupID {
	_scanExpr := scanExpr{memoExpr: memoExpr{op: ScanOp}, table: table}
	_fingerprint := _scanExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeScan(&_scanExpr))
}

func (_f *Factory) ConstructValues(
	rows ListID,
	cols PrivateID,
) GroupID {
	_valuesExpr := valuesExpr{memoExpr: memoExpr{op: ValuesOp}, rows: rows, cols: cols}
	_fingerprint := _valuesExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeValues(&_valuesExpr))
}

func (_f *Factory) ConstructSelect(
	input GroupID,
	filter GroupID,
) GroupID {
	_selectExpr := selectExpr{memoExpr: memoExpr{op: SelectOp}, input: input, filter: filter}
	_fingerprint := _selectExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeSelect(&_selectExpr)
	}

	// [EliminateSelect]
	{
		_true := _f.mem.lookupNormExpr(filter).asTrue()
		if _true != nil {
			_f.maxSteps--
			_group = input
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [EnsureSelectFilters]
	{
		_filters := _f.mem.lookupNormExpr(filter).asFilters()
		if _filters == nil {
			if _f.useFilters(filter) {
				_f.maxSteps--
				_group = _f.ConstructSelect(input, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownSelectJoinLeft]
	{
		_norm := _f.mem.lookupNormExpr(input)
		if isJoinLookup[_norm.op] {
			_e := makeExpr(_f.mem, input, defaultPhysPropsID)
			left := _e.ChildGroup(0)
			right := _e.ChildGroup(1)
			on := _e.ChildGroup(2)
			_filters2 := _f.mem.lookupNormExpr(filter).asFilters()
			if _filters2 != nil {
				list := _filters2.conditions
				for _, _item := range _f.mem.lookupList(_filters2.conditions) {
					condition := _item
					if !_f.isCorrelated(condition, right) {
						_f.maxSteps--
						_group = _f.ConstructSelect(_f.DynamicConstruct(_f.mem.lookupNormExpr(input).op, []GroupID{_f.ConstructSelect(left, condition), right, on}, 0), _f.ConstructFilters(_f.removeListItem(list, condition)))
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [PushDownSelectJoinRight]
	{
		_norm2 := _f.mem.lookupNormExpr(input)
		if _norm2.op == InnerJoinOp || _norm2.op == InnerJoinApplyOp {
			_e2 := makeExpr(_f.mem, input, defaultPhysPropsID)
			left := _e2.ChildGroup(0)
			right := _e2.ChildGroup(1)
			on := _e2.ChildGroup(2)
			_filters3 := _f.mem.lookupNormExpr(filter).asFilters()
			if _filters3 != nil {
				list := _filters3.conditions
				for _, _item := range _f.mem.lookupList(_filters3.conditions) {
					condition := _item
					if !_f.isCorrelated(condition, left) {
						_f.maxSteps--
						_group = _f.ConstructSelect(_f.DynamicConstruct(_f.mem.lookupNormExpr(input).op, []GroupID{left, _f.ConstructSelect(right, condition), on}, 0), _f.ConstructFilters(_f.removeListItem(list, condition)))
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [HoistSelectExists]
	{
		_filters4 := _f.mem.lookupNormExpr(filter).asFilters()
		if _filters4 != nil {
			list := _filters4.conditions
			for _, _item := range _f.mem.lookupList(_filters4.conditions) {
				exists := _item
				_exists := _f.mem.lookupNormExpr(_item).asExists()
				if _exists != nil {
					subquery := _exists.input
					_f.maxSteps--
					_group = _f.ConstructSemiJoinApply(input, subquery, _f.ConstructFilters(_f.removeListItem(list, exists)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [HoistSelectNotExists]
	{
		_filters5 := _f.mem.lookupNormExpr(filter).asFilters()
		if _filters5 != nil {
			list := _filters5.conditions
			for _, _item := range _f.mem.lookupList(_filters5.conditions) {
				exists := _item
				_not := _f.mem.lookupNormExpr(_item).asNot()
				if _not != nil {
					_exists2 := _f.mem.lookupNormExpr(_not.input).asExists()
					if _exists2 != nil {
						subquery := _exists2.input
						_f.maxSteps--
						_group = _f.ConstructAntiJoinApply(input, subquery, _f.ConstructFilters(_f.removeListItem(list, exists)))
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [HoistSelectFilterSubquery]
	{
		_filters6 := _f.mem.lookupNormExpr(filter).asFilters()
		if _filters6 != nil {
			list := _filters6.conditions
			for _, _item := range _f.mem.lookupList(_filters6.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(input, subqueryInput, _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeSelect(&_selectExpr))
}

func (_f *Factory) ConstructProject(
	input GroupID,
	projections GroupID,
) GroupID {
	_projectExpr := projectExpr{memoExpr: memoExpr{op: ProjectOp}, input: input, projections: projections}
	_fingerprint := _projectExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeProject(&_projectExpr)
	}

	// [EliminateProject]
	{
		if _f.projectsSameCols(projections, input) {
			_f.maxSteps--
			_group = input
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeProject(&_projectExpr))
}

func (_f *Factory) ConstructInnerJoin(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_innerJoinExpr := innerJoinExpr{memoExpr: memoExpr{op: InnerJoinOp}, left: left, right: right, on: on}
	_fingerprint := _innerJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeInnerJoin(&_innerJoinExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructInnerJoin(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructInnerJoin(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoin(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeInnerJoin(&_innerJoinExpr))
}

func (_f *Factory) ConstructLeftJoin(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_leftJoinExpr := leftJoinExpr{memoExpr: memoExpr{op: LeftJoinOp}, left: left, right: right, on: on}
	_fingerprint := _leftJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeLeftJoin(&_leftJoinExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructLeftJoin(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructLeftJoin(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructLeftJoin(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeLeftJoin(&_leftJoinExpr))
}

func (_f *Factory) ConstructRightJoin(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_rightJoinExpr := rightJoinExpr{memoExpr: memoExpr{op: RightJoinOp}, left: left, right: right, on: on}
	_fingerprint := _rightJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeRightJoin(&_rightJoinExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructRightJoin(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructRightJoin(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructRightJoin(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeRightJoin(&_rightJoinExpr))
}

func (_f *Factory) ConstructFullJoin(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_fullJoinExpr := fullJoinExpr{memoExpr: memoExpr{op: FullJoinOp}, left: left, right: right, on: on}
	_fingerprint := _fullJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeFullJoin(&_fullJoinExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructFullJoin(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructFullJoin(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructFullJoin(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeFullJoin(&_fullJoinExpr))
}

func (_f *Factory) ConstructSemiJoin(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_semiJoinExpr := semiJoinExpr{memoExpr: memoExpr{op: SemiJoinOp}, left: left, right: right, on: on}
	_fingerprint := _semiJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeSemiJoin(&_semiJoinExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructSemiJoin(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructSemiJoin(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructSemiJoin(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeSemiJoin(&_semiJoinExpr))
}

func (_f *Factory) ConstructAntiJoin(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_antiJoinExpr := antiJoinExpr{memoExpr: memoExpr{op: AntiJoinOp}, left: left, right: right, on: on}
	_fingerprint := _antiJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeAntiJoin(&_antiJoinExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructAntiJoin(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructAntiJoin(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructAntiJoin(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeAntiJoin(&_antiJoinExpr))
}

func (_f *Factory) ConstructInnerJoinApply(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_innerJoinApplyExpr := innerJoinApplyExpr{memoExpr: memoExpr{op: InnerJoinApplyOp}, left: left, right: right, on: on}
	_fingerprint := _innerJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeInnerJoinApply(&_innerJoinApplyExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructInnerJoinApply(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.removeApply(InnerJoinApplyOp, left, right, on)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [TryDecorrelateProject]
	{
		_project := _f.mem.lookupNormExpr(right).asProject()
		if _project != nil {
			input := _project.input
			projections := _project.projections
			_f.maxSteps--
			_group = _f.ConstructSelect(_f.ConstructProject(_f.ConstructInnerJoinApply(left, input, _f.ConstructTrue()), _f.appendColumnProjections(projections, left)), on)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [TryDecorrelateSelect]
	{
		_select := _f.mem.lookupNormExpr(right).asSelect()
		if _select != nil {
			input := _select.input
			filter := _select.filter
			_f.maxSteps--
			_group = _f.ConstructInnerJoinApply(left, input, _f.concatFilterConditions(on, filter))
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [TryDecorrelateScalarGroupBy]
	{
		_groupBy := _f.mem.lookupNormExpr(right).asGroupBy()
		if _groupBy != nil {
			input := _groupBy.input
			_projections := _f.mem.lookupNormExpr(_groupBy.groupings).asProjections()
			if _projections != nil {
				items := _projections.items
				if _f.isEmptyList(items) {
					aggregations := _groupBy.aggregations
					_f.maxSteps--
					_group = _f.ConstructSelect(_f.ConstructGroupBy(_f.ConstructLeftJoinApply(left, input, _f.ConstructTrue()), _f.columnProjections(left), aggregations), on)
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeInnerJoinApply(&_innerJoinApplyExpr))
}

func (_f *Factory) ConstructLeftJoinApply(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_leftJoinApplyExpr := leftJoinApplyExpr{memoExpr: memoExpr{op: LeftJoinApplyOp}, left: left, right: right, on: on}
	_fingerprint := _leftJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeLeftJoinApply(&_leftJoinApplyExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructLeftJoinApply(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructLeftJoinApply(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.removeApply(LeftJoinApplyOp, left, right, on)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructLeftJoinApply(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		_select := _f.mem.lookupNormExpr(right).asSelect()
		if _select != nil {
			input := _select.input
			filter := _select.filter
			_f.maxSteps--
			_group = _f.ConstructLeftJoinApply(left, input, _f.concatFilterConditions(on, filter))
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeLeftJoinApply(&_leftJoinApplyExpr))
}

func (_f *Factory) ConstructRightJoinApply(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_rightJoinApplyExpr := rightJoinApplyExpr{memoExpr: memoExpr{op: RightJoinApplyOp}, left: left, right: right, on: on}
	_fingerprint := _rightJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeRightJoinApply(&_rightJoinApplyExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructRightJoinApply(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructRightJoinApply(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.removeApply(RightJoinApplyOp, left, right, on)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructRightJoinApply(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		_select := _f.mem.lookupNormExpr(right).asSelect()
		if _select != nil {
			input := _select.input
			filter := _select.filter
			_f.maxSteps--
			_group = _f.ConstructRightJoinApply(left, input, _f.concatFilterConditions(on, filter))
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeRightJoinApply(&_rightJoinApplyExpr))
}

func (_f *Factory) ConstructFullJoinApply(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_fullJoinApplyExpr := fullJoinApplyExpr{memoExpr: memoExpr{op: FullJoinApplyOp}, left: left, right: right, on: on}
	_fingerprint := _fullJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeFullJoinApply(&_fullJoinApplyExpr)
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructFullJoinApply(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructFullJoinApply(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.removeApply(FullJoinApplyOp, left, right, on)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructFullJoinApply(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		_select := _f.mem.lookupNormExpr(right).asSelect()
		if _select != nil {
			input := _select.input
			filter := _select.filter
			_f.maxSteps--
			_group = _f.ConstructFullJoinApply(left, input, _f.concatFilterConditions(on, filter))
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeFullJoinApply(&_fullJoinApplyExpr))
}

func (_f *Factory) ConstructSemiJoinApply(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_semiJoinApplyExpr := semiJoinApplyExpr{memoExpr: memoExpr{op: SemiJoinApplyOp}, left: left, right: right, on: on}
	_fingerprint := _semiJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeSemiJoinApply(&_semiJoinApplyExpr)
	}

	// [EliminateSemiAntiJoinProject]
	{
		_project := _f.mem.lookupNormExpr(right).asProject()
		if _project != nil {
			input := _project.input
			_true := _f.mem.lookupNormExpr(on).asTrue()
			if _true != nil {
				_f.maxSteps--
				_group = _f.ConstructSemiJoinApply(left, input, _f.ConstructTrue())
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructSemiJoinApply(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructSemiJoinApply(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.removeApply(SemiJoinApplyOp, left, right, on)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructSemiJoinApply(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		_select := _f.mem.lookupNormExpr(right).asSelect()
		if _select != nil {
			input := _select.input
			filter := _select.filter
			_f.maxSteps--
			_group = _f.ConstructSemiJoinApply(left, input, _f.concatFilterConditions(on, filter))
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [TryDecorrelateScalarGroupBy]
	{
		_groupBy := _f.mem.lookupNormExpr(right).asGroupBy()
		if _groupBy != nil {
			input := _groupBy.input
			_projections := _f.mem.lookupNormExpr(_groupBy.groupings).asProjections()
			if _projections != nil {
				items := _projections.items
				if _f.isEmptyList(items) {
					aggregations := _groupBy.aggregations
					_f.maxSteps--
					_group = _f.ConstructSelect(_f.ConstructGroupBy(_f.ConstructLeftJoinApply(left, input, _f.ConstructTrue()), _f.columnProjections(left), aggregations), on)
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeSemiJoinApply(&_semiJoinApplyExpr))
}

func (_f *Factory) ConstructAntiJoinApply(
	left GroupID,
	right GroupID,
	on GroupID,
) GroupID {
	_antiJoinApplyExpr := antiJoinApplyExpr{memoExpr: memoExpr{op: AntiJoinApplyOp}, left: left, right: right, on: on}
	_fingerprint := _antiJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeAntiJoinApply(&_antiJoinApplyExpr)
	}

	// [EliminateSemiAntiJoinProject]
	{
		_project := _f.mem.lookupNormExpr(right).asProject()
		if _project != nil {
			input := _project.input
			_true := _f.mem.lookupNormExpr(on).asTrue()
			if _true != nil {
				_f.maxSteps--
				_group = _f.ConstructAntiJoinApply(left, input, _f.ConstructTrue())
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [EnsureJoinFilters]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters == nil {
			if _f.useFilters(on) {
				_f.maxSteps--
				_group = _f.ConstructAntiJoinApply(left, right, _f.flattenFilterCondition(on))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [PushDownJoinFilter]
	{
		_filters2 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters2 != nil {
			list := _filters2.conditions
			for _, _item := range _f.mem.lookupList(_filters2.conditions) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.maxSteps--
					_group = _f.ConstructAntiJoinApply(_f.ConstructSelect(left, condition), right, _f.ConstructFilters(_f.removeListItem(list, condition)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.removeApply(AntiJoinApplyOp, left, right, on)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		_filters3 := _f.mem.lookupNormExpr(on).asFilters()
		if _filters3 != nil {
			list := _filters3.conditions
			for _, _item := range _f.mem.lookupList(_filters3.conditions) {
				subquery := _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput := _subquery.input
					projection := _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructAntiJoinApply(left, _f.ConstructInnerJoinApply(right, subqueryInput, _f.ConstructTrue()), _f.ConstructFilters(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		_select := _f.mem.lookupNormExpr(right).asSelect()
		if _select != nil {
			input := _select.input
			filter := _select.filter
			_f.maxSteps--
			_group = _f.ConstructAntiJoinApply(left, input, _f.concatFilterConditions(on, filter))
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeAntiJoinApply(&_antiJoinApplyExpr))
}

func (_f *Factory) ConstructGroupBy(
	input GroupID,
	groupings GroupID,
	aggregations GroupID,
) GroupID {
	_groupByExpr := groupByExpr{memoExpr: memoExpr{op: GroupByOp}, input: input, groupings: groupings, aggregations: aggregations}
	_fingerprint := _groupByExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeGroupBy(&_groupByExpr))
}

func (_f *Factory) ConstructUnion(
	left GroupID,
	right GroupID,
	colMap PrivateID,
) GroupID {
	_unionExpr := unionExpr{memoExpr: memoExpr{op: UnionOp}, left: left, right: right, colMap: colMap}
	_fingerprint := _unionExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeUnion(&_unionExpr))
}

func (_f *Factory) ConstructIntersect(
	left GroupID,
	right GroupID,
) GroupID {
	_intersectExpr := intersectExpr{memoExpr: memoExpr{op: IntersectOp}, left: left, right: right}
	_fingerprint := _intersectExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIntersect(&_intersectExpr))
}

func (_f *Factory) ConstructExcept(
	left GroupID,
	right GroupID,
) GroupID {
	_exceptExpr := exceptExpr{memoExpr: memoExpr{op: ExceptOp}, left: left, right: right}
	_fingerprint := _exceptExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeExcept(&_exceptExpr))
}

type dynConstructLookupFunc func(f *Factory, children []GroupID, private PrivateID) GroupID

var dynConstructLookup [78]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[UnknownOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		panic("op type not initialized")
	}

	// SubqueryOp
	dynConstructLookup[SubqueryOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSubquery(children[0], children[1])
	}

	// VariableOp
	dynConstructLookup[VariableOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructVariable(private)
	}

	// ConstOp
	dynConstructLookup[ConstOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructConst(private)
	}

	// PlaceholderOp
	dynConstructLookup[PlaceholderOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructPlaceholder(private)
	}

	// ListOp
	dynConstructLookup[ListOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructList(f.StoreList(children))
	}

	// OrderedListOp
	dynConstructLookup[OrderedListOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructOrderedList(f.StoreList(children))
	}

	// TupleOp
	dynConstructLookup[TupleOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructTuple(f.StoreList(children))
	}

	// FiltersOp
	dynConstructLookup[FiltersOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFilters(f.StoreList(children))
	}

	// ProjectionsOp
	dynConstructLookup[ProjectionsOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructProjections(f.StoreList(children), private)
	}

	// ExistsOp
	dynConstructLookup[ExistsOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructExists(children[0])
	}

	// AndOp
	dynConstructLookup[AndOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAnd(children[0], children[1])
	}

	// OrOp
	dynConstructLookup[OrOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructOr(children[0], children[1])
	}

	// NotOp
	dynConstructLookup[NotOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNot(children[0])
	}

	// EqOp
	dynConstructLookup[EqOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructEq(children[0], children[1])
	}

	// LtOp
	dynConstructLookup[LtOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLt(children[0], children[1])
	}

	// GtOp
	dynConstructLookup[GtOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructGt(children[0], children[1])
	}

	// LeOp
	dynConstructLookup[LeOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLe(children[0], children[1])
	}

	// GeOp
	dynConstructLookup[GeOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructGe(children[0], children[1])
	}

	// NeOp
	dynConstructLookup[NeOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNe(children[0], children[1])
	}

	// InOp
	dynConstructLookup[InOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIn(children[0], children[1])
	}

	// NotInOp
	dynConstructLookup[NotInOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotIn(children[0], children[1])
	}

	// LikeOp
	dynConstructLookup[LikeOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLike(children[0], children[1])
	}

	// NotLikeOp
	dynConstructLookup[NotLikeOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotLike(children[0], children[1])
	}

	// ILikeOp
	dynConstructLookup[ILikeOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructILike(children[0], children[1])
	}

	// NotILikeOp
	dynConstructLookup[NotILikeOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotILike(children[0], children[1])
	}

	// SimilarToOp
	dynConstructLookup[SimilarToOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSimilarTo(children[0], children[1])
	}

	// NotSimilarToOp
	dynConstructLookup[NotSimilarToOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotSimilarTo(children[0], children[1])
	}

	// RegMatchOp
	dynConstructLookup[RegMatchOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRegMatch(children[0], children[1])
	}

	// NotRegMatchOp
	dynConstructLookup[NotRegMatchOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotRegMatch(children[0], children[1])
	}

	// RegIMatchOp
	dynConstructLookup[RegIMatchOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRegIMatch(children[0], children[1])
	}

	// NotRegIMatchOp
	dynConstructLookup[NotRegIMatchOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotRegIMatch(children[0], children[1])
	}

	// IsDistinctFromOp
	dynConstructLookup[IsDistinctFromOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIsDistinctFrom(children[0], children[1])
	}

	// IsNotDistinctFromOp
	dynConstructLookup[IsNotDistinctFromOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIsNotDistinctFrom(children[0], children[1])
	}

	// IsOp
	dynConstructLookup[IsOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIs(children[0], children[1])
	}

	// IsNotOp
	dynConstructLookup[IsNotOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIsNot(children[0], children[1])
	}

	// AnyOp
	dynConstructLookup[AnyOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAny(children[0], children[1])
	}

	// SomeOp
	dynConstructLookup[SomeOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSome(children[0], children[1])
	}

	// AllOp
	dynConstructLookup[AllOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAll(children[0], children[1])
	}

	// BitandOp
	dynConstructLookup[BitandOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructBitand(children[0], children[1])
	}

	// BitorOp
	dynConstructLookup[BitorOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructBitor(children[0], children[1])
	}

	// BitxorOp
	dynConstructLookup[BitxorOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructBitxor(children[0], children[1])
	}

	// PlusOp
	dynConstructLookup[PlusOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructPlus(children[0], children[1])
	}

	// MinusOp
	dynConstructLookup[MinusOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructMinus(children[0], children[1])
	}

	// MultOp
	dynConstructLookup[MultOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructMult(children[0], children[1])
	}

	// DivOp
	dynConstructLookup[DivOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructDiv(children[0], children[1])
	}

	// FloorDivOp
	dynConstructLookup[FloorDivOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFloorDiv(children[0], children[1])
	}

	// ModOp
	dynConstructLookup[ModOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructMod(children[0], children[1])
	}

	// PowOp
	dynConstructLookup[PowOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructPow(children[0], children[1])
	}

	// ConcatOp
	dynConstructLookup[ConcatOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructConcat(children[0], children[1])
	}

	// LShiftOp
	dynConstructLookup[LShiftOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLShift(children[0], children[1])
	}

	// RShiftOp
	dynConstructLookup[RShiftOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRShift(children[0], children[1])
	}

	// UnaryPlusOp
	dynConstructLookup[UnaryPlusOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructUnaryPlus(children[0])
	}

	// UnaryMinusOp
	dynConstructLookup[UnaryMinusOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructUnaryMinus(children[0])
	}

	// UnaryComplementOp
	dynConstructLookup[UnaryComplementOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructUnaryComplement(children[0])
	}

	// FunctionOp
	dynConstructLookup[FunctionOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFunction(f.StoreList(children), private)
	}

	// TrueOp
	dynConstructLookup[TrueOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructTrue()
	}

	// FalseOp
	dynConstructLookup[FalseOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFalse()
	}

	// ScanOp
	dynConstructLookup[ScanOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructScan(private)
	}

	// ValuesOp
	dynConstructLookup[ValuesOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructValues(f.StoreList(children), private)
	}

	// SelectOp
	dynConstructLookup[SelectOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSelect(children[0], children[1])
	}

	// ProjectOp
	dynConstructLookup[ProjectOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructProject(children[0], children[1])
	}

	// InnerJoinOp
	dynConstructLookup[InnerJoinOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructInnerJoin(children[0], children[1], children[2])
	}

	// LeftJoinOp
	dynConstructLookup[LeftJoinOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLeftJoin(children[0], children[1], children[2])
	}

	// RightJoinOp
	dynConstructLookup[RightJoinOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRightJoin(children[0], children[1], children[2])
	}

	// FullJoinOp
	dynConstructLookup[FullJoinOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFullJoin(children[0], children[1], children[2])
	}

	// SemiJoinOp
	dynConstructLookup[SemiJoinOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSemiJoin(children[0], children[1], children[2])
	}

	// AntiJoinOp
	dynConstructLookup[AntiJoinOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAntiJoin(children[0], children[1], children[2])
	}

	// InnerJoinApplyOp
	dynConstructLookup[InnerJoinApplyOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructInnerJoinApply(children[0], children[1], children[2])
	}

	// LeftJoinApplyOp
	dynConstructLookup[LeftJoinApplyOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLeftJoinApply(children[0], children[1], children[2])
	}

	// RightJoinApplyOp
	dynConstructLookup[RightJoinApplyOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRightJoinApply(children[0], children[1], children[2])
	}

	// FullJoinApplyOp
	dynConstructLookup[FullJoinApplyOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFullJoinApply(children[0], children[1], children[2])
	}

	// SemiJoinApplyOp
	dynConstructLookup[SemiJoinApplyOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSemiJoinApply(children[0], children[1], children[2])
	}

	// AntiJoinApplyOp
	dynConstructLookup[AntiJoinApplyOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAntiJoinApply(children[0], children[1], children[2])
	}

	// GroupByOp
	dynConstructLookup[GroupByOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructGroupBy(children[0], children[1], children[2])
	}

	// UnionOp
	dynConstructLookup[UnionOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructUnion(children[0], children[1], private)
	}

	// IntersectOp
	dynConstructLookup[IntersectOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIntersect(children[0], children[1])
	}

	// ExceptOp
	dynConstructLookup[ExceptOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructExcept(children[0], children[1])
	}

}

func (f *Factory) DynamicConstruct(op Operator, children []GroupID, private PrivateID) GroupID {
	return dynConstructLookup[op](f, children, private)
}
