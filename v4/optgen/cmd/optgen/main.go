package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"

	"github.com/petermattis/opttoy/v4/optgen"
)

var (
	errInvalidArgCount     = errors.New("invalid number of arguments")
	errUnrecognizedCommand = errors.New("unrecognized command")
)

var (
	pkg = flag.String("pkg", "opt", "package name used in generated files")
	out = flag.String("out", "", "output file name of generated code")
)

const useGoFmt = true

func main() {
	flag.Usage = usage
	flag.Parse()

	args := flag.Args()
	if len(args) < 2 {
		flag.Usage()
		exit(errInvalidArgCount)
	}

	cmd := args[0]
	switch cmd {
	case "compile":
	case "exprs":
	case "factory":
	case "ops":
	case "visitor":

	default:
		flag.Usage()
		exit(errUnrecognizedCommand)
	}

	sources := flag.Args()[1:]
	readers := make([]io.Reader, len(sources))
	for i, name := range sources {
		file, err := os.Open(name)
		if err != nil {
			exit(err)
		}

		defer file.Close()
		readers[i] = file
	}

	compiler := optgen.NewCompiler(io.MultiReader(readers...))
	compiled, err := compiler.Compile()
	if err != nil {
		exit(err)
	}

	var writer io.Writer
	if *out != "" {
		file, err := os.Create(*out)
		if err != nil {
			exit(err)
		}

		defer file.Close()
		writer = file
	} else {
		writer = os.Stderr
	}

	switch cmd {
	case "compile":
		writer.Write([]byte(compiled.String()))

	case "exprs":
		err = generateExprs(compiled, writer)

	case "factory":
		err = generateFactory(compiled, writer)

	case "ops":
		err = generateOps(compiled, writer)
	}

	if err != nil {
		exit(err)
	}
}

// usage is a replacement usage function for the flags package.
func usage() {
	fmt.Fprintf(os.Stderr, "Optgen is a tool for generating cost-based optimizers.\n\n")

	fmt.Fprintf(os.Stderr, "It compiles source files that use a custom syntax to define expressions,\n")
	fmt.Fprintf(os.Stderr, "match expression patterns, and generate replacement expressions.\n\n")

	fmt.Fprintf(os.Stderr, "Usage:\n")

	fmt.Fprintf(os.Stderr, "\toptgen command [flags] sources...\n\n")

	fmt.Fprintf(os.Stderr, "The commands are:\n\n")
	fmt.Fprintf(os.Stderr, "\tcompile    generates the optgen compiled format\n")
	fmt.Fprintf(os.Stderr, "\texprs      generates expression definitions and functions\n")
	fmt.Fprintf(os.Stderr, "\texplorer   generates exploration and implementation functions\n")
	fmt.Fprintf(os.Stderr, "\tfactory    generates expression tree creation and normalization functions\n")
	fmt.Fprintf(os.Stderr, "\tops        generates operator definitions and functions\n")
	fmt.Fprintf(os.Stderr, "\n")

	fmt.Fprintf(os.Stderr, "Flags:\n")

	flag.PrintDefaults()

	fmt.Fprintf(os.Stderr, "\n")
}

func exit(err error) {
	fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
	os.Exit(2)
}

func generateExprs(compiled optgen.CompiledExpr, w io.Writer) error {
	var gen optgen.ExprsGen
	return generate(compiled, w, gen.Generate)
}

func generateFactory(compiled optgen.CompiledExpr, w io.Writer) error {
	var gen optgen.FactoryGen
	return generate(compiled, w, gen.Generate)
}

func generateOps(compiled optgen.CompiledExpr, w io.Writer) error {
	var gen optgen.OpsGen
	return generate(compiled, w, gen.Generate)
}

func generate(compiled optgen.CompiledExpr, w io.Writer, genFunc func(compiled optgen.CompiledExpr, w io.Writer)) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by optgen; DO NOT EDIT.\n\n")
	fmt.Fprintf(&buf, "  package %s\n\n", *pkg)

	genFunc(compiled, &buf)

	var b []byte
	var err error

	if useGoFmt {
		b, err = format.Source(buf.Bytes())
		if err != nil {
			// Write out incorrect source for easier debugging.
			b = buf.Bytes()
		}
	} else {
		b = buf.Bytes()
	}

	w.Write(b)
	return err
}
